# Syntaxe pour  les scripts [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html){#syntax}

Cette page est simplement destinée à rechercher les instructions des scripts du PsyToolkit. Elle suppose que vous savez plus ou moins ce que vous recherchez. Si vous êtes nouveau à PsyToolkit, il est plus facile de commencer à regarder certains des exemples ici ou des exemples plus détaillés dans la bibliothèque d'expériences.

[Lien rapide vers toutes les instructions](#s5-15)

Autres documents pertinents (en anglais) :

* [Informations générales sur PsyToolkit](https://www.psytoolkit.org/doc3.1.0/about.html)
* [Informations générales sur les scripts](https://www.psytoolkit.org/doc3.1.0/introscripting.html)
* [Aide détaillée sur les scripts et la version hors ligne](http://www.psytoolkit.org/software/)

## Comment utiliser cette page de présentation des scripts d'expériences [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_how_to_use_this_experiment_script_overview_page){#how_to_use_this_experiment_script_overview_page}

Cette page énumère tous les éléments possibles d'un script PsyToolkit. Elle donne également une brève description syntaxique. Une syntaxe est une description de la manière dont les instructions peuvent être utilisées. Dans la description syntaxique, les arguments obligatoires d'une instruction sont entre crochets []. Les arguments optionnels entre crochets normaux (). Un signe | indique différentes valeurs valides pour un argument.

Par exemple, prenons l'exemple de l'instruction "show rectangle". L'exemple ci-dessous montre qu'il y a 4 arguments obligatoires : X,Y,W,H. Il s'agit de la coordonnée x, de la coordonnée y, de la largeur et de la hauteur. Les arguments Rouge, Vert et Bleu sont optionnels (par défaut, un rectangle est blanc, mais vous pouvez lui donner des couleurs différentes)

* show rectangle [X,Y,W,H](Rouge,Vert,Bleu)

Les parenthèses dans la description de la syntaxe ne sont bien sûr pas tapées dans le vrai script ; c'est juste une façon de décrire une syntaxe. Regardez attentivement les exemples donnés pour chaque instruction pour voir comment utiliser les instructions.

## Structure des scripts [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_structure_of_scripts){#structure_of_scripts}

Il existe différentes sections dans les scripts, et chaque section est séparée des autres par au moins une ligne vide.
Tout ce qui suit un hashtag (#) est un commentaire uniquement pour les yeux humain, l'ordinateur l'ignorera.
Les principales sections qui contiennent chacune plusieurs lignes sont les suivantes :

* [options de base](#s5-3) décrit des paramètres pratiques du PsyToolkit qui ne sont pas par défaut, tels que la taille de l'écran
* [options avancées](#s5-4) décrit les options avancées que les débutants peuvent ignorer
* [options linux](#s5-5) uniquement options avancées spéciales lors de l'utilisation de la version Linux
* [bitmaps/sons/fonts](#4-6) décrit les stimuli à utiliser
* [La tâche](#s5-7) peut être utilisée plusieurs fois pour décrire les essais de paradigmes
* [Le tableau](#s5-8) peut être utilisé plusieurs fois pour décrire les conditions expérimentales
* [le bloc](#s5-9) peut être utilisé plusieurs fois pour exécuter des blocs d'essais
* [l'ordre des blocs](#s5-10) peut être fixé de manière différente (utilisateurs avancés uniquement)

## Option de base [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options){#options}

Chaque fois que vous programmez une expérience, vous pouvez vouloir vous écarter des valeurs par défaut. Par exemple, la taille d'écran par défaut d'une expérience est de 800 par 600 pixels, mais vous pouvez la modifier en utilisant l'option "resolution". Les options disponibles sont énumérées ci-dessous. Au bas de cette section se trouve un exemple complet.

Il existe de nombreuses options, mais elles sont surtout destinées aux utilisateurs avancés. Si vous êtes nouvel utilisateur de PsyToolkit, ignorez dans un premier temps les options.

### resolution [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-resolution){#options-resolution}

Cela détermine la résolution de l'expérience. Cette résolution par défaut est de 800 par 600. Lorsque vous spécifiez la résolution, il s'agit de la largeur par la hauteur, séparées seulement par un espace. Voir l'exemple ci-dessous.

**Exemple de plein écran (avec un rectangle de saut aléatoire)**
````
options
  fullscreen
  resolution 1000 800

task MyTask
  set $x random -300 300 # random x position
  set $y random -300 300 # random y position
  set $mysize random 10 100
  show rectangle $x $y $mysize $mysize   255 0 0 # show red rectangle
  delay 100
  clear -1

block MyBlock
  tasklist
    MyTask 200
  end
  
````

### background color [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-background){#options-backgroundcolor}

Vous pouvez spécifier la couleur de fond de l'écran. Par défaut, il est noir, mais vous pouvez le régler ici sur une couleur différente. Vous pouvez la spécifier en utilisant un nom de couleur (rouge, vert, bleu, blanc, jaune, rose, violet, noir, orange) ou un triplet RVB (255 0 0 pour le rouge), ou une combinaison hexadécimale de six lettres/chiffres (FF0000 pour le rouge).

**Exemple de fond**
````
options
  background color white

task MyTask
  set $x random -300 300 # random x position
  set $y random -300 300 # random y position
  set $mysize random 10 100
  show rectangle $x $y $mysize $mysize   255 255 0 # show yellow rectangle
  delay 100
  clear -1

block MyBlock
  tasklist
    MyTask 200
  end
  
````

**Un autre exemple utilisant un triplet RGB (dans ce cas, blanc)**
````
options
  background color 255 255 255
````

**Un autre exemple utilisant un hexa code**
````
options
  background color FFFF00
````

### fullscreen [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-fullscreen){#options-fullscreen}

Exécute l'expérience en mode plein écran. Sous Linux, c'est le mode par défaut, alors que dans le navigateur, ce n'est pas le cas.

Dans la version en ligne (Javascript), le mode plein écran ne fonctionne pas dans le navigateur Safari d'Apple (Apple n'autorise pas le mode plein écran et la saisie au clavier).

**Exemple de plein écran (avec un rectangle de saut aléatoire)**
````
task MyTask
  set $x random -300 300 # random x position
  set $y random -300 300 # random y position
  set $mysize random 10 100
  show rectangle $x $y $mysize $mysize   255 255 0 # show yellow rectangle
  delay 100
  clear -1

block MyBlock
  tasklist
    MyTask 200
  end
````

### mouse [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-mouse){#options-mouse}

Par défaut, le curseur de la souris n'est pas affiché, car d'un point de vue psychologique, il peut être un stimulus distrayant. Mais pour certaines expériences, la souris est nécessaire en tant que dispositif de pointage. Cette option permet de s'assurer que le curseur de la souris est visible. La seule valeur utile est "on".

**Exemple d'affichage de la souris dans une expérience**
````
options
  mouse on
````
L'option ne met la souris en marche qu'au début de l'expérience. Vous pouvez toujours l'éteindre plus tard dans une tâche en utilisant les instructions de masquage et d'affichage de la souris. [Cliquez ici pour en savoir plus sur ces deux instructions](#task-mouse).

### set [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-set){#options-set}

Cela vous permet de définir une variable globale. Cela peut être pratique si vous souhaitez tester un paramètre expérimental (par exemple, l'intervalle intertrial) à une valeur spécifique tout au long de l'expérience. Si vous n'utilisez la variable nulle part, cette valeur sera simplement ignorée.

**Exemple de "set" dans les options**
````
options
  fullscreen
  set &my_intertrialinterval 100

task MyTask
  set $x random -300 300 # random x position
  set $y random -300 300 # random y position
  set $mysize random 10 100
  show rectangle $x $y $mysize $mysize   255 0 0 # show red rectangle
  delay 100
  clear -1
  delay &my_intertrialinterval

block MyBlock
  tasklist
    MyTask 200
  end
````

Il est parfois pratique d'avoir défini certains paramètres de base dans les options en tant que variables globales. De cette façon, vous pouvez facilement les retrouver. De bons exemples sont les intervalles entre les essais, les temps de réponse maximums autorisés, la taille du stimulus, etc.

### start messages [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-start-messages){#options-start-messages}

Dans la version en ligne, chaque expérience commence par une case rouge et le message en anglais "Click to start". En outre, selon le temps nécessaire pour charger les messages, vous verrez un message attendre une seconde. Vous pouvez modifier ces deux messages avec les deux options suivantes :

**Exemple de modification des messages de démarrage**
````
options
  startbutton text My own click-to-start message
  loading text My own wait-a-second message
````

## Options avancées [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#advanced_options){#advanced_options}

### var in [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_var_in){#var_in}

[Voir l'échange d'information entre les questionnnaires et les expériences](#s11)

Lorsque vous utilisez PsyToolkit dans le cadre d'enquêtes en ligne, vous pouvez échanger des variables numériques entre les expériences et une enquête.

Vous ne pouvez changer que des variables numériques en nombre entier. C'est-à-dire des nombres tels que 12 ou 3, mais pas des lettres, des combinaisons de chiffres et de lettres, ni des nombres fractionnaires (tels que 12.1 ou 3.4)

Par exemple, vous pouvez poser une question d'enquête demandant l'âge d'une personne, puis utiliser l'âge comme variable dans l'expérience. Vous devez préciser le nom de l'enquête. Vous trouverez ci-dessous un exemple.

**Exemple d'une question d'enquête en premier lieu. Note : il ne s'agit donc pas d'un code de script d'expérimentation !**
````
l: sleep
t: range
q: how many hours sleep did you have?
- {min=0,max=10} Select number

l: alcohol
t: range
q: how many glasses of alcohol did you dring?
- {min=0,max=20} Select number

l: the_experiment
t: experiment
- my_experiment

l: information
t: info
q: Your score is {$xxx} and {$yyy}.
````

Dans l'expérience suivante, les participants sont invités à répondre à un rectangle. Supposons que les personnes endormies ou celles qui consomment de l'alcool ont besoin de plus de temps, nous voulons leur donner plus de temps, afin de leur donner le maximum de temps pour répondre plus longtemps. Nous créons une nouvelle variable MyMaxTime basée sur leur consommation d'alcool et leurs heures de sommeil. Plus ils ont bu ou moins ils ont dormi, plus &MyMaxTime sera élevé. Ceci montre simplement comment vous pouvez utiliser les variables

Notez que les variables sommeil et alcool sont traitées comme des variables globales, et doivent être précédées du signe &.

**Exemple d'utilisation d'une réponse à une enquête dans le cadre d'une expérience**
````
options
  var in sleep alcohol

task myTask
  keys space
  show rectangle 0 0 100 100
  set &MyMaxTime expression 1000 + 100 * &alcohol + 100 * ( 10 - &sleep )
  readkey 1 &MyMaxTime
  save RT

block
  tasklist
    myTask 10
  end
````

### var out [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_var_out){#var_out}

[Voir l'échange d'information entre les questionnnaires et les expériences](#s11)

L'option var out peut être utilisée pour sauvegarder une valeur créée dans une expérience directement dans l'enquête. Dans ce cas, la valeur sauvegardée sera disponible dans le feuille de calcul du questionnaire.

**Exemple d'utilisation d'une réponse à une enquête dans le cadre d'une expérience**

````
options
  var out my_score
````
**Exemple de question d'enquête fonctionnant avec cela. Notez que ce script est destiné aux enquêtes en ligne uniquement.**

````
l: my_feedback
t: info
q: Your score was {$my_score}
````

### origin [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-origin){#options-origin}

Les stimuli visuels sont présentés à l'écran, et vous devez donner une coordonnée X et une coordonnée Y pour les placer. L'option d'origine indique à l'ordinateur où se trouve le point X=0,Y=0 (ou 0,0).

Par défaut, le point de coordonnées 0,0 est au centre de l'écran. Vous pouvez également définir le coin supérieur gauche de l'écran comme origine (ce qui était la valeur par défaut dans les anciennes versions de PsyToolkit).

**Exemple d'utilisation de l'instruction origin**

````
options
  origin topleft
````

### fontdir,datadir,bitmapdir,sounddir [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-sounddir){#options-sounddir}

Les options fontdir,datadir,bitmapdir,sounddir vous permettent de modifier les dossiers dans lesquels l'ordinateur s'attend à ce que les stimuli soient enregistrés. Vous n'avez pas besoin de le préciser si les fichiers de stimuli se trouvent dans le même répertoire que votre code de script.

Cette option est particulièrement utile si vous travaillez en C ou si vous faites de grandes expériences.

## Options pour Linux [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-sounddir){#options-sounddir}

### escape (C seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-escape){#options-escape}

Dans la version Linux Desktop, cela permet de terminer le programme en appuyant sur la touche d'échappement. Veuillez noter que l'ordinateur vérifie uniquement si la touche d'échappement a été enfoncée à la fin de chaque essai. Par conséquent, si vous utilisez cette option, et si vous souhaitez interrompre votre expérience, vous devez maintenir le bouton d'échappement (ou tout autre bouton utilisé pour l'échappement) pendant la durée d'au moins un essai.

Dans le navigateur, vous pouvez toujours vous échapper de votre expérience, et là, cette option n'est pas nécessaire.

### parallelport (C seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-parallelport){#options-parallelport}

Il s'agit d'un codage avancé du port parallèle.

### pcidio24 (C seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-pcidio24){#options-pcidio24}

This is for advanced coding of the pcidio24 port

### cedrus (C seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-cedrus){#options-cedrus}

Cela indique que vous avez attaché un clavier Cedrus. En option, vous pouvez spécifier un modèle. Si vous spécifiez un modèle, le script ne fonctionnera qu'avec ce modèle. Cette rigueur n'est nécessaire que dans le cas où vous voulez forcer les gens à utiliser un clavier Cedrus spécifique.

### iolab (C seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-iolab){#options-iolab}


Il semble que cet appareil ne soit plus produit. PsyToolkit le supporte toujours.

Cela indique que vous avez connecté le dispositif IoLab (un clavier spécial avec des boutons poussoirs). En option, vous pouvez spécifier les paramètres des touches vocales (voir psycc -s)

### et (Linux seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-et){#options-et}

Le soutien à l'eye-tracker Tobii est en cours de développement. Actuellement, le code est en cours de développement pour le modèle tx300. Cela ne fonctionne que sur linux

**Exemple de comment informer PsyToolkit sur votre eye-tracker Tobii**
````
options
  et tobii 12345
````

Le numéro 12345 est ici un exemple d'identification d'un tracker Tobii. Il est facultatif de donner ce numéro d'identification.

### sprites first (Linux seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-sprites-first){#options-sprites-first}

**Utilisation avancée uniquement**

L'option "sprites first" attirera les sprites avant qu'elle n'attire d'autres stimuli. Cela signifie que les sprites seront dessinés en arrière-plan, ce que vous souhaitez pour certaines situations.

### executable [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-executable){#options-executable}

Le nom de fichier du programme exécutable. Par défaut, c'est *experiment*, mais il peut être défini avec l'option de ligne de commande -o et avec cette option.

L'option -o remplacera cette option. Dans la version en ligne, cette option sera ignorée.

### egi (C only) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-egi){#options-egi}

Avec le nom ou l'adresse IP de l'hôte et le port IP (facultatif), il établit une connexion avec le système d'Electrical Geodesics, Inc. Ce système n'a pas été bien testé et est basé sur un ancien code. Vous n'avez pas besoin d'utiliser d'options si vous ne le souhaitez pas.

**Exemple de toutes les options de base**
````
options
  resolution 1024 800
  fullscreen
  mouse off
  set &my_variable 100
````

### vsync on|off [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options_vsync_off){#options_vsync_off}

**Non pertinent pour la version en ligne et pour utilisateurs avancés uniquement**. En mode Linux, il est "activé" par défaut, mais peut être désactivé, car certaines cartes graphiques ne permettent pas d'utiliser le vsync. PsyToolkit affichera un message d'erreur s'il n'est pas disponible.

S'il est réglé sur "off", l'ordinateur n'attend pas la synchronisation du vsync (c'est la valeur par défaut en Javascript). C'est pratique pour les tests, car l'expérience ne nécessite pas l'autorisation de l'administrateur principal lors de la compilation. En C, si vous utilisez l'option -t, c'est la valeur par défaut.

**Exemple de vsync désactivé**
````
option
  vsync off
````

### window (C only) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-window){#options-window}

Cela vous permet de mener l'expérience dans une fenêtre plutôt qu'en plein écran. C'est pratique pour les tests. Notez que le mode plein écran est le mode par défaut dans Linux, sauf si vous exécutez en mode test.

Comme PsyToolkit peut fonctionner dans deux environnements de programmation différents, certaines fonctions ne marchent pas dans tous les environnements. Les fonctions C ne fonctionnent que sur la version Linux qui est basée sur le langage de programmation C. Si vous utilisez la version en ligne, vous pouvez les ignorer complètement.

### screensize and screendistance (C only) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-screendistance){#options-screendistance}

Vous pouvez définir les dimensions de l'écran et la distance entre les yeux et l'écran. Les unités sont en millimètres. Ces chiffres sont nécessaires si vous voulez utiliser l'option coordonnées polaires ou si vous voulez utiliser l'option de ligne de commande de la taille du stimulus du rapport. Si vous utilisez un système de coordonnées polaires (ce qui est rare), toutes les coordonnées xy doivent être spécifiées en centièmes de degrés (donc 100 = 1 degré, 200 = 2 degrés d'angle visuel). Ceci n'est pas encore bien implémenté (faites-moi savoir si vous en avez besoin).

### version [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-version){#options-version}

Ce service est réservé aux utilisateurs avancés. Cela permettra uniquement de compiler un script avec la version psycc correspondante. C'est pratique si vous avez plusieurs versions de psycc installées, et si vous voulez juste vous assurer que le code fonctionne. Cette commande n'a aucun effet dans la version en ligne.

### check_refresh_rate [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#options-check-refresh-rate){#options-check-refresh-rate}

Linux seulement. Vous pouvez vérifier si le taux de rafraîchissement est conforme aux attentes, et si ce n'est pas le cas, un message sera affiché à l'écran.

Ceci est utile si vous avez un moniteur avancé et que vous voulez vous assurer que le taux de rafraîchissement n'est pas réinitialisé à une valeur inférieure par un autre gestionnaire de bureau. Notez que seul XFCE dispose d'un moyen agréable de définir la fréquence de rafraîchissement (settings→display).

**Exemple de check_refresh_rate**
````
options
  resolution 1920 1080
  check_refresh_rate 144
````

Dans l'exemple ci-dessus, nous avons réglé l'écran sur ce qui est aujourd'hui une résolution standard (pour en savoir plus sur ce qu'on appelle le "full HD"). Ensuite, nous disons à l'ordinateur que nous nous attendons à ce que la carte graphique et l'écran fonctionnent à un taux de rafraîchissement de 144 Hz. PsyToolkit ne peut pas le régler, mais il peut le vérifier. Si PsyToolkit constate que l'écran ne fonctionne pas à la fréquence de rafraîchissement prévue, il envoie un message puis s'arrête.

**Exemple de toutes les options de base**
````
options
  fontdir     /usr/lib/fonts
  datadir     /home/user/mydatadir
  bitmapdir   /usr/local/bitmaps
  sounddir    /usr/local/snd
  origin      topleft
  window
  resolution 1024 800
  screensize 1000 600
  screendistance 500
  coordinates polar
  vsync off
  escape
  egi 10.0.0.42
  parallelport in data out 1 5
  pcidio24 in a b out c_low c_high
  cedrus
  iolab
  executable myexperiment
  set &myinterval 100
  sprites first
````

## Chargement des stimuli [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#loadingstimuli){#loadingstimuli}

L'ordinateur doit savoir quels stimuli vous utilisez. Les stimuli sont généralement des images ou des sons, qui doivent être chargés. Vous pouvez également charger des polices de caractères. Vous trouverez ci-dessous des explications sur la manière de charger des images, des sons et des polices.

![](img/attention.png) Les noms de fichiers bitmap et sons **ne doivent pas commencer par un chiffre**, ni contenir d'espaces ou de caractères spéciaux (à l'exception du soulignement).


### bitmaps [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_bitmaps){#bitmaps}

La commande bitmaps vous permet de définir un certain nombre de images que vous souhaitez utiliser dans votre expérience. Les images peuvent être de formats courants, png, jpg, bmp et autres.

La ligne bitmaps n'a pas de paramètres et est suivie de lignes décrivant l'image, chaque image ayant un nom et une description de fichier.

Ne mettez rien entre guillemets, et n'utilisez pas d'espaces dans les descriptions ou dans les noms de fichiers.

Si vous n'ajoutez pas de nom de fichier, cela suppose qu'un nom de fichier existe avec l'extension .png. Dans l'exemple ci-dessous, PsyToolkit suppose qu'un fichier house.png existe car aucune autre information bitmap n'est donnée. C'est en fait la méthode de travail recommandée (c'est certainement la plus simple).

**Exemple de bitmaps et comment s'y référer dans une tâche**
````
bitmaps
  house
  funnyface funny.bmp
  cookie    stimuli/cookie.jpeg
  smiley    smiley

task MyTask
  show bitmap funnyface
  show bitmap cookie 100 0
````

Notez que pour les expériences en Javascript dans un navigateur, il existe deux autres façons de charger les bitmaps :

1. en utilisant le préfixe http:// (donc, au lieu d'un nom de fichier complet, donnez l'URL). Cette façon de procéder est logique dans des circonstances très particulières et n'est généralement pas recommandée, sauf si vous savez vraiment ce que vous faites. La raison est que cela peut réduire considérablement le temps de téléchargement des expériences en ligne. En effet, par défaut, tous les stimuli sont intégrés dans le fichier HTML via data:uri, ce qui peut conduire à des fichiers HTML volumineux.

Voici comment vous procédez dans PsyToolkit

**Exemple de chargement de bitmaps à partir de sites web externes**
````
bitmaps
  house http://www.my-website.com/house.png

task MyTask
  show bitmap house
````

2. utilisation de data:image/ uris

Pour plus d'informations sur le fonctionnement de l'URI, [voir Wikipedia](http://en.wikipedia.org/wiki/Data_URI_scheme)

Les données uri ne sont utilisées que dans des cas très rares et spéciaux, et ne sont généralement pas recommandées (parce qu'elles ne sont pas vraiment nécessaires, mais il existe des raisons techniques inhabituelles pour lesquelles quelqu'un pourrait vouloir les obtenir dans des conditions très inhabituelles)

**Exemple de chargement d'images utilisant une URI**

````
bitmaps
  testimage data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAAGElEQVQIW2P4DwcMDAxAfBvMAhEQMYgcACEHG8ELxtbPAAAAAElFTkSuQmCC

task MyTask
  show bitmap testimage
````

### move [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#move){#move}

*move* et relocate ne sont pas souvent utilisés. Ils sont surtout réservés aux animations de base et sont alors très pratiques.
*move* ne donne pas une animation fluide, c'est juste un changement de lieu. Voir la leçon sur les animations simples pour plus de détails.
Parfois, vous voulez changer l'emplacement d'un stimulus que vous avez déjà créé à l'écran. Cela peut être utile pour les animations simples.

Vous pouvez le faire avec deux fonctions différentes dans les tâches :

* *move*
* *relocate* (décrit ci-après)

L'exemple suivant montre un stimulus au centre de l'écran et, après 1000 ms, déplace le stimulus de 20 pixels vers la droite, sans changer l'emplacement y. Ainsi, le déplacement donne la quantité de changement X et Y (alors que le déplacement donne une nouvelle position X/Y complète).

**Exemple de déplacement d'un stimulus**
````
bitmaps
  smiley.png

task MyTask
  show bitmap smiley
  delay 1000
  move 1 20 0
````

### relocate [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#relocate){#relocate}

*relocate* est très similaire à *move*, sauf que vous ne faites que donner les nouvelles coordonnées.

**Exemple de relocalisation d'un stimulus**

````
bitmaps
  smiley.png

task MyTask
  show bitmap smiley
  delay 1000
  relocate 1 100 150
````

### sounds [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#sounds){#sounds}

Cela fonctionne comme les commandes "bitmaps", simplement pour indiquer à l'ordinateur quels sons sont chargés. Vous pouvez utiliser n'importe quel format de fichier son, bien que le format de fichier wav soit le plus largement utilisé et recommandé pour les études en ligne.

**Exemple de sons et comment s'y référer dans une [tâche](#s5-7)**

````
sounds
  barkingdog bark.wav
  phone      ringingphone.mp3

task MyTask
  sound phone
  delay 300
````
Comme pour les images bitmap, vous pouvez également charger un son à partir d'un serveur web (en utilisant http://). L'avantage est que cela permet d'accélérer le temps de chargement.

Vous pouvez également utiliser des sons dans le bloc, par exemple pour faire jouer de la musique lorsque le participant effectue la tâche. Cela peut être utilisé pour tester l'effet de différents types de sons, de musique, de bruit de fond sur l'exécution de la tâche. [Voir le son dans un bloc](#block-sound).

### fonts [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#fonts){#fonts}

Par défaut, si vous ne précisez pas à l'ordinateur quelle police vous souhaitez utiliser, PsyToolkit utilisera Arial 20 points. Vous n'avez pas besoin de définir une police si vous ne voulez rien d'autre qu'un Arial de taille 20 points.

Vous pouvez décrire ici les polices à utiliser. Vous pouvez utiliser les polices intégrées (arial, times, courier) ou charger les polices ttf (depuis la version) 2.3.3 également en Javascript. Si vous les utilisez en ligne, vous devez télécharger votre ttf comme vous téléchargez n'importe quel autre stimulus.

Notez que les mêmes polices portent des noms différents. Si vous ne connaissez pas les types les plus courants, consultez WikiPedia pour obtenir des [informations sur Arial](https://en.wikipedia.org/wiki/Arial), des [informations sur Times New Roman](https://en.wikipedia.org/wiki/Times_New_Roman) et des [informations sur Courier](https://en.wikipedia.org/wiki/Courier_%28typeface%29).

Vous pouvez utiliser l'un des trois types de police par défaut : arial, times ou courier. Si vous utilisez l'une de ces trois polices, vous n'avez pas besoin de télécharger ou d'inclure un fichier de police, car ces polices sont déjà disponibles sur les ordinateurs. Sous Linux, Arial=FreeSans.ttf, Times=FreeSerif.ttf, et Courier=FreeMono.ttf.

**Exemple de polices et comment s'y référer dans une [tâche](#task)**
````
fonts
  arial 18
  myfont times 20
  mysmallfont arial.ttf 20
  mybigfont   arial.ttf 40

task MyTask
  font mysmallfont
  show text "hello"
  delay 1000
  font mybigfont
  show text "world"
  delay 1000
  font arial
  show text "Some text in standard arial"
  font myfont
  show text "Some text in Times New Roman"
  delay 1000
````

voir aussi [Show text](#task-show-text)

### videos [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#videos){#videos}

Vous pouvez utiliser des vidéos dans votre expérience. Vous devez indiquer à PsyToolkit où les vidéos sont stockées sur Internet. Vous ne pouvez pas les stocker sur le serveur PsyToolkit lui-même.

Il est plus facile de télécharger un fichier vidéo sur le Google Drive ou sur la Dropbox. Il y a une [leçon sur la façon de le faire en détail (en anglais)](https://www.psytoolkit.org/lessons/video.html).

Vous pouvez donner n'importe quel nom à la vidéo, par exemple, dans l'exemple ci-dessous, clip1 et clip2 ont été choisis, mais il pourrait tout aussi bien s'agir de my_video1 et my_video2.

**Exemple d'une section vidéo avec deux clips**
````
videos
  clip1 https://www.dropbox.com/s/kzo7sx7hkdai16i/beetle.mp4?dl=0
  clip2 https://www.dropbox.com/s/bzbs6qpk7ht9yyu/frog.mp4?dl=0
````
## Les tâches [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task){#task}

Dans PsyToolkit, une tâche décrit (typiquement) la séquence d'un seul essai d'une expérience.

Les tâches sont la partie la plus difficile du langage de script, car elles impliquent l'écriture de véritables instructions informatiques séquentielles pour montrer des stimuli, attendre des réponses, etc. Beaucoup de choses sont possibles, et il existe de nombreux types d'instructions différentes. Chaque type d'instruction est décrit ci-dessous.

Avant de décrire les instructions, un certain nombre d'éléments fondamentaux du langage sont décrits, à savoir la structure des tâches, les variables et les repères temporelles

### Comment les tâches sont structurées [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_how_tasks_are_structured){#how_tasks_are_structured}

Les tâches servent en fait à programmer ce qui se passe dans un essai de paradigme expérimental. Une tâche n'est qu'une séquence d'instructions, terminée par une ligne vide. Les instructions contiennent les grandes parties d'information suivantes :

* Où se trouve une description des différentes conditions expérimentales. Cela peut être fait avec l'état de la [table](#task-table)
* Comment le participant doit-il réagir exactement (par exemple, quelles touches du clavier, ou avec la souris). Cela peut être fait, par exemple, avec [keys](#task-keys) et [readkeys.](#task-readkey)
* Les stimuli utilisés, ainsi que le moment et le lieu où ils doivent être présentés. Cela peut se faire avec [show](#task-show) et [sound](#task-sound).
* Les données qui doivent être enregistrées dans un fichier pour une analyse ultérieure des données. Cela se fait avec l'instruction [save](#task-save)

### le concept de variables [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#variables-explained){#variables-explained}

Comme tout langage informatique, vous pouvez utiliser des variables. Il existe des variables globales et des variables locales. En principe, vous pouvez toujours utiliser des variables globales. Les variables locales ne sont utilisées que dans une tâche, tandis que les variables globales peuvent être utilisées n'importe où dans la tâche et le code de bloc (voir aussi blocs). Vous pouvez définir les valeurs initiales des variables globales dans les options.

Vous pouvez définir une variable avec l'instruction *set*.

**Exemple de définition et d'utilisation des variables**
````
task MyTask
  set $x 100
  set &y 10
  show bitmap FunnyFace $x &y
````

* Les variables ne peuvent avoir que des valeurs entières. Un entier est un nombre entier. Par exemple, $x est 100, il ne peut pas être 100.342, car ce dernier n'est pas un nombre entier.
* Le signe égal n'est pas utilisé pour attribuer des valeurs aux variables ! C'est-à-dire pas de symbole "=" comme on le ferait dans la plupart des langages de programmation.
* Les variables ne peuvent pas commencer par un nombre, ne peuvent pas contenir d'espaces, de signes moins, de points ou de caractères spéciaux, à l'exception du soulignement.

De bons exemples.

* $MyVariable1
* ma_variable_1
* $xyz

![](img/attention.png) Les écritures suivantes ne sont **pas autorisées** !!!!!!

* $My Variable 1 (raison : pas d'espaces autorisés)
* $My.variable.1 (raison : pas de points autorisés)
* $My-variable-1 (raison : pas de signes moins autorisés)
* $My\*variable (raison : aucun caractère spécial tel que "\*" n'est autorisé)
* 123my_variable (raison : ne peut pas commencer par un numéro)

Il existe également des types particuliers de variables écrites en majuscules, comme RT, STATUS, TABLEROW, TASKNAME, BLOCKNAME, BLOCKNUMBER, BLOCKORDER. Elles vous donnent simplement accès à des informations importantes sur une réponse ou sur l'état de la tâche.

### Le concept d'horodatage [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#timestamp){#timestamp}

l'horodatage (timestamps) est un type spécial de variable, mais il n'est utilisé que dans des scripts très avancés et n'est normalement pas nécessaire. Chaque fois que vous définissez un timestamps, l'heure courante est enregistrée.

### La fonction set [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-set){#task-set}

Avec set, vous pouvez assigner des valeurs à des [variables](#variables-explained).

````
set [$&] [nom de la variable] [nouvelle valeur, variable ou expression]
````

Comme  nous l'avons expliqué à propos des "variables", la fonction set peut fixer la valeur des variables.

* Une variable est un élément de base dans tout langage de programmation. Une variable est simplement un symbole qui contient une valeur. Par exemple, x = 10. PsyToolkit ne peut fonctionner qu'avec des nombres entiers comme valeurs.
* set est une fonction relativement avancée, et lors de l'apprentissage de PsyToolkit, vous n'en avez pas immédiatement besoin, et vous pouvez écrire des scripts sans set.
* set est une fonction relativement avancée, et lorsque vous apprenez PsyToolkit, vous n'en avez pas immédiatement besoin, et vous pouvez écrire des scripts sans set. set est une variable locale qui a une valeur (le $ indique qu'elle est locale)

**définir une variable locale à une valeur (le $ indique qu'elle est locale)**
````
set $x 10
````

**définir une variable globale à une valeur (le & indique qu'elle est golabale)**
````
set &x 10
````

Dans ce qui suit, la nature locale ou globale de la variable n'est pas pertinente pour expliquer l'ensemble, et nous travaillons simplement avec $x

**prendre la valeur d'une autre variable**
````
set $x &y
````

**augmenter la valeur d'une variable**
````
set $x 10
set $x increase 2  # after this, $x has value 12
````

**diminuer la valeur d'une variable (le pas par défaut est de 1)**
````
set $x 10
set $x decrease # after this, $x has value 9
````

**utiliser une expression mathématique**
````
set $x expression $x / 2 + $a + 1
````

**Tirer une valeur aléatoire**
````
set $x random 1 10
````

**Tirer une valeur aléatoire avec un pas de 2**
````
set $x random 2 100 2
````

**Tirer une valeur aléatoire d'un ensemble spécifique de valeurs**
````
set $x random from 1 2 3 5 10
````

**régler la valeur de la carte d'entrée/sortie pcidio24 (si vous en avez une !) (pour les utilisateurs avancés, Linux uniquement)**
````
set $x pcidio24 a # set to value of register A
````

**régler sur les millisecondes qui se sont écoulées depuis le début de l'expérience (pour les utilisateurs avancés)**
````
set $x time-since-start
````

**régler sur la différence en millisecondes de deux horodatages (pour les utilisateurs avancés)**
````
timestamp MyTime1
delay 500
timestamp MyTime2
set $x timestamp-diff MyTime1 MyTime2 # now x should be 500
````

**obtenir l'horodatage en secondes et millisecondes (pour les utilisateurs avancés)**
````
timestamp MyTime1
dely 2500
timestamp MyTime2
set $x timestamp-seconds MyTime2 # value should be 2
set $x timestamp-milliseconds MyTime2 # value should be 2500
````

**obtenir le temps en millisecondes depuis le 1er janvier 1970 (pour les utilisateurs avancés)**
````
set $x unix-time
save $x
````

**obtenir le numéro de l'image actuellement sous la souris (pour les utilisateurs avancés)**
````
bitmaps
  myface
  yourface
  smileyface

task test
  show bitmap yourface -100 0    ## first bitmap
  show bitmap smileyface 200 200 ## second bitmap
  readmouse l 1 1000
  set $myMouseX MOUSE_X # current mouse x-coordinate
  set $myMouseY MOUSE_Y # current mouse x-coordinate
  set $x bitmap-under-mouse $myMouseX $myMouseY ## $x should be 1
  ````

### Synthèse de la fonction set [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_summary_of_set){#summary_of_set}

Le set n'est pas nécessaire pour les débutants ! Il permet vraiment une flexibilité dans votre code, si vous le voulez et en avez besoin.
Pour chaque fonction set, vous pouvez utiliser des variables locales ou globales. Ne vous inquiétez pas de la différence entre les variables locales et globales ; en cas de doute, utilisez des variables globales (en commençant par le signe &).

**Usages basiques**

+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| **Instructions de base**                           | **Exemple**                    | **Résultat**                                                     |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Assigner une valeur à une variable locale          | set \$x 10                     | $x contient 10 (seules les valeurs entières sont permisses)      |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Assigner une valeur à une variable globale         | set &g 12                      | &g contient 12                                                   |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Assigner une valeur à partir d'une autre variable  | set &h RT                      | avec une commande *readkey* plus tôt, donne la valeur de RT à &h |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Tirer une valeur aléatoire                         | set &x random 1 5              | &x contient une des valeurs 1,2,3,4 ou 5                         |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Tirer une valeur aléatoire avec un pas             | set &x random 1 10 2           | &x contient une des valeurs 1,3,5,7 ou 9                         |
+---------------------------------------------------+--------------------------------+-------------------------------------------------------------------+
| Augmenter la valeur d'une variable                 | set &x increase                | si &x contient 5, après la commande il contiendra 6              |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Augmenter la valeur d'une variable avec une valeur | set &x increase                | si &x contient 5, après la commande il contiendra 8              |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Diminuer                                           | set &a decrease                | fonctionne comme increase, sauf qu'elle diminue la valeur        |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+
| Assigner une valeur à partir d'une expression      | set \$y expression \$x * 3 + 5 | si &x contient 5 alors \$y sera de 20                            |
+----------------------------------------------------+--------------------------------+------------------------------------------------------------------+

**Usages avancés**

+----------------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------+
| **gestion du temps**                                           | **Exemple**                           | **Resultat**                                                                            |
+----------------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------+
| Temps depuis le début de l'expérience en ms                    | set \$j time-since-start              | si votre expérience a démarré depuis 5 secondes \$j contiendra 5000                     |
+----------------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------+
| Calculer la différence entre deux horodatages                  | set \$t timestamp-diff Time1 Time2    | si Time1 a été mesuré plus tôt que Time2, \$t contiendra la différence en millisecondes |
+----------------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------+
| Calculer la différence entre deux horodatages en secondes      | set \$t timestamp-seconds Time1       | l'horodatage en secondes                                                                |
+----------------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------+
| Calculer la différence entre deux horodatages en millisecondes | set \$ms timestamp-milliseconds Time1 | l'horodatage en millisecondes                                                           |
+----------------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------+

+-----------------------------------------------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------+
| **Contrôles de la souris**                                                  | **Exemple**                            | **Resultat**                                                                           |
+-----------------------------------------------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------+
| Trouver le numéro du stimulus cliqué                                        | set \$b bitmap-under-mouse             | si le dernier stimulus cliqué est le 5, \$b contient 5                                 |
+-----------------------------------------------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------+
| Trouver le numéro du stimulus cliqué en ne considérant que certains numéros | set \$b bitmap-under-mouse range 10 15 | si le dernier stimulus cliqué est 11 a été cliqué, $b contiendra 11. Les autres stimuli seront ignorés. Ceci est pratique pour les stimuli qui se chevauchent. |
+-----------------------------------------------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------+

+---------------------------------------+-------------------------+-------------------------------------------------------+
| **Autres fonctions avancées**         | **Exemple**             | **Resultat**                                          |
+---------------------------------------+-------------------------+-------------------------------------------------------+
| Trouver le dernier stimulus affiché   | set \$c show-counter    | Si vous avez montré le stimulus 10, \$c contient 10   |
+---------------------------------------+-------------------------+-------------------------------------------------------+

+--------------------------------------------------+-------------------------+---------------------------------------------------------------------------------+
| **Autres fonctions Linux seulement**             | **Exemple**             | **Resultat**                                                                    |
+--------------------------------------------------+-------------------------+---------------------------------------------------------------------------------+
| Récupérer la valeur d'une carte PCI-DIO24        | set \$z pcidio24 a      | mettre \$z à la valeur de 8 bits du canal a (valeur comprise entre 0 et 255)    |
+--------------------------------------------------+-------------------------+---------------------------------------------------------------------------------+
| Position x courante à l'écran du symbole         | set \$x sprite-x 2      | Si on affiche un symbole 2, met dans \$x la coordonnée x à l'écran du symbole   |
+--------------------------------------------------+-------------------------+---------------------------------------------------------------------------------+
| Position y courante à l'écran du symbole         | set \$y sprite-y 2      | Si on affiche un symbole 2, met dans \$y la coordonnée y à l'écran du symbole   |
+--------------------------------------------------+-------------------------+---------------------------------------------------------------------------------+

## Instructions de base [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_commonly_used_instructions){#commonly_used_instructions}
Il existe de nombreuses instructions différentes pour montrer les stimuli, enregistrer et sauvegarder les réponses. Elles sont toutes énumérées ci-dessous avec un bref exemple de leur utilisation. Cette section décrit ceux qui sont le plus souvent utilisés, et que vous devez vraiment comprendre.

Avant de commencer, voici une liste alphabétique des instructions les plus couramment utilisées :

**présentation des stimuli**

* [Show](#task-show) montre un stimulus sur l'écran
* [clear](#task-clear) supprime un stimulus de l'écran
* [sound](#task-sound) joue un son

**la mesure des réponses et des délais de réponse**

* [keys](#task-keys) indique à l'ordinateur quelles sont les touches utilisées dans une tâche
* [readkey](#task-readkey) attend une pression sur le clavier
* [readkeys](#task-readkeys) attent qu'on appuie plusieurs fois sur le clavier
* [readmouse](#task-readkeys) attend un clic ou un mouvement de souris
* [choose](#task-choose) la sélection de stimuli multiples avec la souris
* [rate](#task-rate),  la façon la plus simple d'inclure l'échelle de Likert dans votre expérience

**Gérer  le temps**

* [delay](#task-delay) d'attente en millisecondes

**sauvegarde des données**

* [save](#task-save), sauvegarde les données dans un fichier

**informer l'ordinateur sur les conditions d'expérimentation**

* [table](#task-table) indique où se trouvent les conditions de l'expérience

**conditions**

* [if](#task-if), faire quelque chose qui dépend de d'une ou des variable(s)
* [while](#task-while) faire quelque chose qui dépend de d'une ou des variable(s)
* [set](#task-set) définir une variable

Chacune de ces instructions est détaillée ci-dessous.

### keys [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-keys){#task-keys}

**syntaxe**
````
keys [liste de touches]
````

Au début de la description d'une tâche, vous devez indiquer à l'ordinateur les touches du clavier sur lesquelles les participants devront éventuellement appuyer. Cette ligne doit être l'une des premières lignes de la description de la tâche.

Les touches données seront associées à un numéro de clavier, commençant par un. Vous pouvez l'utiliser lors de la sauvegarde des données. La variable KEY contiendra cette valeur lorsqu'une touche a été enfoncée.

**exemple d'utilisation de keys utilisant deux touches**
````
keys a z
````

Liste de toutes les touches disponibles sur toutes les plateformes :

* lettres : a à z
* les chiffres : 0 à 9
* touches spéciales : enter, capslock, tab, space, end, home, insert
* touches spéciales : escape, slash, backslash, quote, comma, period
* touches fléchées : haut bas droite gauche
* clavier numérique (keypad) : kp0 kp1 kp2 kp3 kp4 kp5 kp6 kp7 kp8 kp9
clavier numérique : kp_period kp_slash kp_star kp_minus kp_plus kp_enter

Les touches suivantes ne sont pas disponibles en mode Javascript

* touches de déplacement : lshift rshift
* touches de contrôle : lcontrol rcontrol
* touches alt : lalt ralt
* touches logo : lsuper rsuper

### mouse on or off [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-mouse){#task-mouse}

Vous pouvez masquer (off) ou afficher (on) le curseur de la souris. Regardez les lignes suivantes que vous pouvez utiliser dans une tâche.

**Exemple d'affichage ou de masquage du curseur de la souris dans une tâche**
````
task MyTask
  show bitmap smileyface
  mouse hide
  delay 1000
  show bitmap smileyface
  mouse show
  delay 1000
````

### table [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#table){#task-table}

**syntaxe**
````
table [nom de la table]
````

Une instruction *table* permet de définir une table (qui est définie séparément de la tâche, et elle contiendra des informations sur les différentes instructions expérimentales).les tables vous permettent d'avoir une description de tâche pour différentes conditions. De cette façon, vous pouvez faire varier la couleur, la position ou la taille des stimuli. Chaque ligne d'une table sera considérée comme la description d'une condition expérimentale différente.  C'est un élément clé des scripts PsyToolkit, bien que vous puissiez aussi écrire des scripts sans table !

Si vous avez plus d'une tâche et plus d'une table, vous devez spécifier dans votre tâche quelle table lui appartient. La ligne du tableau choisie sur une épreuve donnée se trouve dans la variable TABLEROW.

**Exemple de table**
````
table MyTable
````

### show [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show){#task-show}

**syntaxe**
````
show [bitmap|text|rectangle|circle|video](X,Y)(…)
````

C'est une instruction essentielle qui permet de montrer les stimuli des types suivants: 

* [un rectangle](#task-show-rectangle)
* [un cercle](#task-show-circle)
* [une ligne](#task-show-text)
* [une image](#task-show-bitmap) 
* [une vidéo](#task-show-video)
* [un fond de couleur](#task-show-background)

Le nombre de paramètres donnés pour une instruction *show* peut varié. Vous trouverez [ici une explication détaillée](#s4-2) de la façon dont vous présentez vos stimuli à l'écran, là où vous voulez qu'ils soient.

### show bitmap [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show-bitmap){#task-show-bitmap}
**syntaxe**
````
show bitmap [nom de l'image](X,Y)
````
Imaginez que vous avez chargé une image dans la section " bitmap " de votre description de tâche. Vous pouvez maintenant la montrer. Il vous suffit de spécifier le fichier image, et celui-ci s'affichera au centre de l'écran. Vous pouvez également spécifier les coordonnées X et Y (facultatif).

**Exemple d'usage de show bitmap**
````
show bitmap MyBitmap
show bitmap MyBitmap 200 10
````
****
Plus d'informations sur la façon de montrer les images sont disponibles dans [cette leçon](https://www.psytoolkit.org/lessons/show_bitmaps.html).

****

### show rectangle[![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show-rectangle){#task-show-rectangle}
*syntaxe**
````
show rectangle X,Y,Width,Height, Red,Green,Blue
````
Vous pouvez afficher des rectangles colorés, en spécifiant la position X et Y ainsi que la largeur et la hauteur. Vous devez également spécifier les valeurs Rouge, Vert et Bleu. Cela signifie que vous aurez 7 paramètres supplémentaires !

Dans l'exemple ci-dessous, un rectangle est affiché à la position 0,0 et il a une largeur et une hauteur de 100 pixels. Les valeurs rouge/vert/bleu sont fixées à 255/0/0. La valeur maximale dans chacun de ces trois canaux de couleur est 255. Étant donné que seul le rouge est spécifié, le rectangle sera rouge.

PsyToolkit utilise le modèle de couleur Rouge-Vert-Bleu (RVB). Chaque couleur peut être spécifiée comme une combinaison de rouge, de vert et de bleu. Pour chacune de ces trois couleurs de base, vous devez donner une valeur comprise entre zéro et 255. Vous pouvez créer n'importe quelle couleur, voir le [modèle RVB sur wikipedia](http://fr.wikipedia.org/wiki/Rgb). Il existe des [sites web](https://www.rapidtables.com/web/color/RGB_Color.html) où vous pouvez créer vos propres couleurs :

+---------------+--------------+--------------+-------------+
| **Couleur**   | **Rouge**    | **Vert**     | **Bleu**    |
+---------------+--------------+--------------+-------------+
| Blanc         | 255          | 255          | 255         |
+---------------+--------------+--------------+-------------+
| Rouge pur     | 255          | 0            | 0           |
+---------------+--------------+--------------+-------------+
| Bleu pur      | 0            | 0            | 255         |
+---------------+--------------+--------------+-------------+
| vert pur      | 0            | 255          | 0           |
+---------------+--------------+--------------+-------------+
| Jaune         | 255          | 255          | 0           |
+---------------+--------------+--------------+-------------+
| Gris          | 128          | 128          | 128         |
+---------------+--------------+--------------+-------------+
| Orange        | 255          | 128          | 0           |
+---------------+--------------+--------------+-------------+
| Rose          | 255          | 100          | 180         |
+---------------+--------------+--------------+-------------+

**Exemple d'usage de show rectangle**
````
show rectangle 0 0 100 100 255 0 0
````
### show circle [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show-circle){#task-show-circle}
Montrer un cercle. Simailaire à *show rectangle*. 

**syntaxe**
````
show circle X,Y,Radius, Red,Green,Blue
````
Le troisième paramètre est  le rayon en pixels (donc le diametre est le double du rayon).

**Exemple d'usage de show circle**
````
show circle 0 0 100   255 0 0
````

### show background [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show-background){#task-show-background}

**syntaxe**
````
show background (Red,Green,Blue)
````

Il existe également un moyen plus simple de le définir en utilisant l'option [couleur de fond](#options-background).

Parfois, vous voulez que l'ensemble de l'écran ait une couleur spécifique. En principe, vous pouvez simplement dessiner un rectangle de la taille de l'écran. C'est exactement ce que fait la fonction "show background". Il vous suffit de donner les trois paramètres de couleur et l'écran entier sera rempli de cette couleur. Sinon, elle est traitée comme un stimulus d'écran normal, elle a un numéro et peut être effacée.

**Exemple d'usage de show background**
````
show background 100 100 100 ## creates a grey background
delay 500
show rectangle 100 200 200 0 0 ## draw red rectangle
delay 1000
clear -1 ## erase the the rectangle
````

****
Vous n'avez pas besoin d'effacer le fond d'écran. Il restera jusqu'au prochain essai (ce qui est en général ce que les gens veulent)

****

### show text [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show-text){#task-show-text}

L'instruction *show text* montre un texte.

**Exemple basique d'usage de show text pour Linux**
````
table MyFirstTable
  10 "some text"
  15 "some other text"

task MyTask
  show text "Some green text"  0 0   0 255 0
  show text @2  0 0   0 255 0
````
Par défaut, si vous ne dites pas à l'ordinateur quelle police vous voulez utiliser, PsyToolkit utilisera Arial 20 points. Vous n'avez pas besoin de définir une police si vous ne voulez rien d'autre qu'un Arial de taille 20 points. Il existe de nombreuses polices ttf disponibles gratuitement sur le web. Par exemple avec [Font Squirrel](https://www.fontsquirrel.com/). Si vous le souhaitez, vous pouvez également spécifier une police et une taille de police dans la section [fonts](#fonts).

**syntaxe**
````
show text [text](X,Y)(Red,Green,Blue)
````
**Exemple basique d'usage de show text avec une font spécifique**
````
fonts
  MyArial comic.ttf 20

table MyFirstTable
  10 "some text"
  15 "some other text"

task MyTask
  font MyArial
  table MyFirstTable
  show text "Some green text"  0 0   0 255 0
  show text @2  0 0   0 255 0
````
L'alignement par défaut est "centré". Cela signifie que si vous demandez de présenter quelque chose  à la position 10,10, c'est là que se trouve le centre du mot. Voir la façon de définir l'alignement dans l'exemple ci-dessous. Notez également que vous pouvez définir la couleur du texte pour toutes les commandes "show text" suivantes, vous pouvez ainsi afficher un mot en couleur.

Alors que "show text ..." sert à afficher le texte, vous pouvez régler l'alignement des couleurs séparément. C'est pratique si vous voulez par exemple présenter plusieurs textes dans la même couleur.

**Exemple d'instructions text et show text avec alignement et couleur**
````
fonts
  arial 20

task MyTask
  text color yellow
  text align center
  show text "Some text with alignment: center"  0 -100
  text align left
  show text "Some text with alignment: left" 0 0
  text align right
  show text "Some text with alignment: right"  0 100
  delay 10000

block test
  tasklist
    MyTask 1
  end
````
Les   couleurs de mots suivantes sont actuellement implémentées : blanc, jaune, rouge, vert, bleu, rose, violet, noir, gris, orange, rose.
Pour la "couleur du texte", vous pouvez également spécifier la couleur avec trois valeurs décimales ou sous forme de code hexadécimal à 6 caractères. Dans l'exemple ci-dessous pour la même couleur jaune es décalrée de trois manières différentes. Cet exemple n'a aucun sens dans une expérience réelle (pourquoi spécifier la même couleur trois fois de suite ?), mais montre simplement comment utiliser l'instruction "text color".

**Exemple d'usage de text color**
````
  # specify color as word:
  text color yellow
  # specify color as Red Green Blue code:
  text color 255 255 0
  # specify color as Hexadecimal value:
  text color FFFF00
````
### show video [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-show-video){#task-show-video}

**Exemple de vidéo au centre de l'écran**
````
   show video my_clip
````

**Exemple d'une vidéo qui peut être placée comme les autres stimuli**
````
   show video my_clip -100 100
````

**Exemple d'une vidéo muette (sans son)**
````
   videocontrol my_clip mute
   show video my_clip -100 100
````
### clear [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-clear){#task-clear}

**syntaxe**
````
clear [Numéro d'ordre de l'image ou liste de numéro d'ordre d'images]
````

Pour effacer un stimulus que vous mettez à l'écran avec "show", vous pouvez l'effacer avec "clear". L'appel "clear" prend au moins un paramètre. Le nombre correspond au numéro des appels de show. Par exemple, si vous voulez effacer un bitmap particulier qui a été montré comme le deuxième événement de show dans votre tâche, utilisez "clear 2". Vous pouvez également utiliser des numéros de référence négatifs pour vous référer aux stimuli précédents : -1 correspond à la dernière image bitmap présentée ! L'utilisation des références négatives est en fait beaucoup plus facile à utiliser, car de cette façon vous n'avez pas besoin de compter les bitmaps.

![](img/attention.png) Le compteur des images est remis à zéro à chaque essai !


**Exemple d'utilisation de clear**
````
show bitmap redcircle
show bitmap greencircle
delay 500
clear 2 # clears the second presented bitmap
# or
show bitmap redcircle
show bitmap greencircle
delay 500
clear -1 # clears last presented bitmap, that is "green circle"
# or
show bitmap redcircle
show bitmap greencircle
delay 500
clear 1 2 # clears both bitmaps
````

Parfois, vous voulez effacer tellement de stimuli qu'il est désagréable de devoir taper tous les numéros S'ils sont dans une plage. Vous pouvez spécifier la plage. Par exemple, *clear range 1 10* efface les stimuli 1 2 3 4 5 6 8 9 10.
Il est rare que vous souhaitiez effacer tout l'écran. Ce n'est pas recommandé pour raisons de temps, car cela peut être plus lent que de changer de petites parties de l'écran, mais vous pouvez vouloir effacer tout l'écran au début ou à la fin d'un essai. Pour ce faire, vous pouvez utiliser la fonction *clear screen*.

### hide/unhide [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-hide){#task-hide}

La fonction de *hide* fait exactement ce que fait la fonction de *clear*, sauf que de cette façon, vous pouvez aussi à nouveau afficher le stimulus (unhide). En utilisant *hide*, vous ne changez pas le numéro d'ordre du stimulus. Cela peut parfois être pratique.

### rotate{#rotate}

Il est possible de faire pivoter les images présentées avec la commande "show bitmap". Un bon exemple est donné dans l'exemple de [Mackworth](http://www.psytoolkit.org/experiment-library/mackworth.html) dans la bibliothèque d'expériences PsyToolkit.

L'angle est indiqué en dixième de degrés. Ainsi un angle de 90 degrés est noté 900

**Exemple de rotation d'une image**
````
rotate next 900
show bitmap MyBitmap
````

**Exemple de rotation d'une image déjà affichée à l'écran**
````
show bitmap
delay 500
rotate 1 900
````

### delay [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-delay){#task-delay}

L'instruction de delay met le programme en pause pendant le nombre de millisecondes spécifié. Vous aurez souvent besoin de cette fonction, par exemple, si vous souhaitez afficher un stimulus pendant un intervalle de temps spécifique, ou pour attendre entre deux essais.

**syntaxe**
````
delay[millisecondes]
````
**Exemmple de pause montrant comment afficher un stimulus pendant 200 ms**
````
show bitmap MyBitmap
delay 200
clear -1
````
Le paramètre de delay (dans l'exemple 200) peut être une variable ou une entrée de tableau. Regardez bien les exmples pour savoir comment faire.

### readkey [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-readkey){#task-readkey}

L'instruction readkeys demande à l'ordinateur d'attendre un appui touche au clavier. Le premier argument est la touche correcte corresondant aux touches dans l'instruction [keys](#keys).

**syntaxe**
````
readkey[numéro de la touche correcte][temps de réponse maximum]
````

Dans l'exemple suivant, il y a deux touches possibles dans la tâche (appelée MyTask), la touche a et la touche z. Imaginez qu'un stimulus nécessite d'appuyer sur la touche z, c'est-à-dire la deuxième touche (a étant la première de la ligne "keys"). La commande de readkey sera alors de 3 secondes pour une pression sur la touche. Si les participants appuient sur la touche z, l'ÉTAT sera réglé sur CORRECT (qui est égal à la valeur numérique 1). Si les participants appuient sur la mauvaise touche, celle-ci sera FAUSSE (valeur numérique 2), et s'il n'y a pas de réponse du tout dans un délai de 3000 ms, le code de STATUT sera TIMEOUT (valeur numérique 3).

**Exemple avec readkey**
````
task MyTask
  keys a z
  show bitmap PressTheZkey
  readkey 2 3000
````
Après un appel à readkey, l'utilisateur peut utiliser les variables suivantes :

* RT (avec le temps de réponse en millisecondes, c'est-à-dire l'heure de l'événement d'appui de la touche)
* TT (l'heure à laquelle la touche a été libérée)
* STATUT (avec les valeurs CORRECT, FAUX, ou TIMEOUT, ou 1,2, ou 3)

### keystatus [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-keystatus){#task-keystatus}

La commande keystatus est réservée à un usage avancé et ne fonctionne que sous Linux (c'est-à-dire pas la version web)
Sous certaines conditions, vous souhaitez vérifier directement l'état du clavier. Vous pouvez le faire avec la commande keystatus. Vous pouvez (en option) spécifier quelle touche vous souhaitez que le clavier soit correct.

**Exemple avec keystatus**
````
task checkKey
  keys a l
  show rectangle 0 0 50 50   255 0 0
  timestamp MyTime1
  timestamp MyTime2
  while $x < 5000 ## run while-loop for 5 secs
   keystatus ## read the keyboard status
   if KEY == 1 ## key "a"
     unhide 1 ## display the rectangle
   fi
   if KEY == 2 ## key "l"
     hide 1 ## hide the rectangle if l is pressed
   fi
   set $x timestamp-diff MyTime1 MyTime2 # now x should be 500
   nap ## give the computer some rest in the while loop
  while-end
````
### readkeys [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-readkeys){#task-readkeys}

La fonction "readkey" est utile pour la plupart des expériences, où il suffit d'appuyer sur une seule touche en réponse à un stimulus. Dans un certain nombre d'expériences, vous pouvez souhaiter que les gens puissent taper un mot (ou une séquence de lettres). La commande readkeys vous permet de le faire. Regardez l'exemple ci-dessous. La commande readkeys comporte de nombreuses options, ce qui peut sembler un peu plus difficile (voir la liste ci-dessous).La commande permet d'effacer un caractère. La touche Retour "termine" la saisie des readkeys.
Il y a également un exemple de code dans la leçon (en anglais) sur la [mesure des temps de réponses avec readkeys](https://www.psytoolkit.org/lessons/readkeys.html).

**Exemple avec readkeys**
````
bitmaps
  apple ## a picture of an apple
  empty_box ## an empty rectangle used as letter placeholder

fonts
  arial 20

task my_task
  text color yellow
  show bitmap apple
  readkeys "apple" 10000
  save RT STATUS
````

Une fonction plus complexe utilise les options de readkeys.

Notez que, par défaut :

* les lettres tapées seront affichées à l'écran (vous pouvez les cacher avec l'option readkeys hide)
* il n'y a pas de places réservées (voir l'exemple ci-dessous pour savoir comment afficher les places réservées)
* la couleur de la police est blanche par défaut (vous pouvez la définir différemment avec, par exemple, textcolor yellow)
*la taille maximale du tableau est de 100 (ce qui est en pratique beaucoup plus long que ce dont vous pourriez avoir besoin)
* les lettres seront affichées à partir du centre de l'écran
* la première police définie (dans la section des polices) sera utilisée
* l'espacement par défaut des lettres sera de 25 pixels

Options de readkeys :

* readkeys option size number : combien de lettres peuvent être tapées au maximum.
* readkeys option show : les lettres tapées seront affichées à l'écran (à partir du centre de l'écran)
* readkeys option show x_position y_position : les lettres tapées seront affichées comme indiqué par la position x/y
* hide : les lettres tapées ne seront pas affichées à l'écran
* readkeys option space number : Les lettres seront espacées par ce nombre de pixels
* readkeys option placeholders image : Il y aura des places réservées sous la forme d'image (telle que définie dans les bitmaps)
* readkeys option placeholders Width Height : Les places réservées seront des rectangles de taille *Largeur* par *Hauteur*

**Voici un exemple avec certaines options**
````
bitmaps
  apple ## a picture of an apple
  empty_box ## an empty rectangle used as letter placeholder

fonts
  my_arial arial 20

task my_task
  text color yellow
  show bitmap apple
  text color red
  readkeys option size 5
  readkeys option show 100 50
  readkeys option placeholders empty_box
  readkeys font font1
  readkeys "apple" 10000
  save RT STATUS
````

Quelques explications sur l'exemple ci-dessus :

* text color red : La commande readkeys affichera les lettres en rouge
* option readkeys size 5 : 5 lettres au maximum peuvent être tapées
* readkeys option placeholders empty_box : L'espace réservé sera l'image bitmap empty_box telle que donnée par l'utilisateur dans la liste des bitmaps
* readkeys option show  100 50 : les lettres tapées sont affichées à l'écran à la position 100 50.
* readkeys option font my_arial : La police my_arial sera utilisée

Dans l'exemple ci-dessus, la dernière ligne de readkeys attend pendant 10 000 ms que les personnes aient entré une ou plusieurs lettres (le participant appuyant sur la touche retour/entrée met fin à l'entrée). Si les personnes ont saisi "apple", leur statut est réglé sur "correct" (c'est-à-dire la valeur 1).

### readmouse [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-readmouse){#task-readmouse}

Pour la version sans clic de readmouse, cela a légèrement changé dans la version 3.1.0

Comme pour la touche de lecture, vous pouvez vérifier si le participant a cliqué sur la touche de la souris et, si oui, si la souris était à l'endroit où elle devait être. Vous pouvez aussi simplement attendre que la souris soit déplacée dans une certaine zone de l'écran. En fait, vous pouvez vérifier si l'emplacement d'un stimulus spécifique a été touché par la souris (bitmap, ou rectangle, ou texte).

Voici les différentes options

* Attendre que la souris soit cliquée et que la souris soit au bon endroit
* Attendre que le participant déplace la souris au bon endroit

Dans l'exemple suivant, nous montrons deux rectangles, et nous voulons que le participant passe la souris sur le rectangle vert (le premier bitmap), qui est positionné à gauche (-200). Nous donnons au maximum 5 secondes, c'est-à-dire 5000 millisecondes.

**Exemple de readmouse sans cliquer**
````
task checkMouse
  show rectangle -200 0 40 40  0 255 0 # green rect, left
  show rectangle  200 0 40 40  255 0 0 # red rect, right
  readmouse 1 5000
  save STATUS RT
````
	Dans l'exemple ci-dessus, vous obtenez un STATUT correct si le rectangle de gauche a été survolé, et vous obtenez un STATUT incorrect si le rectangle de droite est survolé.  Au cas où il y aurait plus de stimuli à l'écran, il est recommandé d'utiliser le paramètre range, comme indiqué ci-dessous.

**Exemple de readmouse sans cliquer et utilisant range**
````
task checkMouse
  show rectangle 0 0 700 500   100 100 100
  show rectangle -200 0 40 40  0 255 0 # green rect, left
  show rectangle  200 0 40 40  255 0 0 # red rect, right
  readmouse 2 5000 range 2 3
  save STATUS RT
````
Dans l'exemple ci-dessus, le premier rectangle est un rectangle gris qui n'est qu'un fond. Comme ce rectangle est presque aussi grand que l'ensemble de l'écran d'expérimentation, nous devons dire à PsyToolkit que nous ne nous soucions pas du survol de ce stimulus par la souris. Pour ce faire, nous utilisons *range* dans l'instruction de readmouse. Cela signifie, dans ce cas, qu'il ne faut vérifier que si le stimulus 2 ou le stimulus 3 a été survolé.

Dans l'exemple suivant, nous avons exactement la même tâche, mais nous voulons un clic de souris dans le premier stimulus. Nous ajoutons l'argument "l" représentant le bouton gauche de la souris. En Javascript, il est recommandé de n'utiliser que le bouton gauche de la souris, car le bouton droit peut afficher un menu contextuel dans le navigateur , ce que vous ne souhaitez évidemment pas.

**Exemple avec readmouse**
````
task checkMouse
  show rectangle -200 0 40 40  0 255 0 # green rect, left
  show rectangle  200 0 40 40  255 0 0 # red rect, right
  readmouse l 1 5000
  save STATUS RT
````
Un problème se pose lorsque les stimuli se chevauchent. Imaginez la situation suivante. Vous avez un grand rectangle qui est juste leur pour montrer un rectangle jaune clair, et au dessus de cela, un rectangle beaucoup plus petit. Si vous voulez que les gens cliquent sur ce second rectangle plus petit, vous devez dire à l'ordinateur que vous ne vous souciez pas du premier. La façon de le faire est de spécifier la gamme de bitmaps qui vous intéresse. Voir l'exemple ci-dessous :

**Exemple avec readmouse**
````
task checkMouse
  show rectangle -200 0 400 400  255 255 0 # big yellow rectangle
  show rectangle  50 0 40 40  255 0 0 # small red one
  readmouse l 2 5000 range 2 2 # wait for second one being clicked
  save STATUS RT
````
Enfin, il existe un cas spécial de survol, où vous pouvez demander à readmouse de ne répondre que si la souris survole la cible demandée, et de ne pas répondre par erreur pour tout autre stimulus. Pour cela, il vous suffit d'ajouter l'option find.
**Exemple de readmouse sans cliquer et utilisant find**
````
task checkMouse
  show rectangle -200 0 40 40  0 255 0 # green rect, left
  show rectangle  200 0 40 40  255 0 0 # red rect, right
  readmouse 1 5000 find
  save STATUS RT
````
Dans le cas ci-dessus, vous pouvez survoler le rectangle de droite, mais PsyToolkit l'ignorera complètement et ne considérera que le stimulus de gauche. Cela peut être utile dans certaines situations. Par exemple, si vous voulez qu'un participant trouve un objet parmi d'autres. Le participant peut passer le curseur sur tous les objets jusqu'à ce quil ait vu l'objet cible. Vous pouvez bien sûr aussi le faire avec une *range*, mais cette solution est un raccourci car ici, vous n'avez pas besoin de connaître exactement les numéros du paramètre *range*, ce qui simplifie les choses.

### progress [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-progress){#task-progress}

PsyToolkit peut afficher une barre de progression. Cela peut être utile si vous voulez dire aux gens combien d'essais ont été effectués et combien de temps il faudra pour les terminer.

Les barres de progression peuvent distraire. Si vous faites une expérience sur l'attention visuelle ou la mémoire, vous devez vous demander si vous pensez que le fait de regarder la barre de progression peut interférer avec le processus cognitif que vous étudiez.
En fait, il est très facile de le montrer. Il existe un certain nombre d'options pour colorer et former la barre de progression comme vous le souhaitez, mais la valeur par défaut est une simple barre de progression horizontale étroite en haut de l'écran.

La commande est simple : *show progressbar done todo*

Le premier chiffre correspond aux essais réalisés jusqu'à présent et le second au nombre total d'essais que le participant devra réaliser.

Dans l'exemple ci-dessous, la commande show progress affiche la barre de progression. Elle est suivie par TRIALCOUNT (essais effectués jusqu'à présent) et le nombre total d'essais (ici par exemple 30).

**Exemple de barre de progression**
````
task exampletask
  show progress TRIALCOUNT 30
  delay 1000
  show mystimulus
````

Il existe un ensemble d'options sécifiques que vous pouvez définir dans le cadre de votre tâche (et non dans la section des options). Vous trouverez ci-dessous un exemple dans lequel vous pouvez définir les deux couleurs (une pour la couleur des essais effectués et une pour la couleur de fond, par défaut ce sont le vert et le gris, respectivement).

**Exemple de barre de progression avec options**
````
task exampletask
  progress option size 0 290 600 10
  progress option color1 255 255 0
  progress option color2 128 128 128
  progress option between 5
  show progress TRIALCOUNT 30
  delay 1000
  show mystimulus
````

Ces options ont la signification suivante.

* size : position X (milieu de la barre de progression), position Y, largeur, hauteur
* color1 : La couleur des essais réalisés (en format Rouge/Vert/Bleu)
* color2 : La couleur des essais réalisés (en format Rouge/Vert/Bleu)
* between : L'espace entre les essais (par exemple, choisir 2 pour un petit écart entre chaque point d'avancement)

Notez qu'au lieu de color1 et de color2, vous pouvez aussi simplement écrire :

**Exemple de barre de progression avec options**
````
progress option colors 255 255 0    128 128 128
````

### choose [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-choose){#task-choose}

Dans certaines circonstances, vous souhaitez demander au participant de cliquer sur plusieurs stimuli à l'écran. Idéalement, vous voudriez permettre au participant de sélectionner des objets et de les désélectionner également. Tout cela est possible avec la fonction "choisir".

En bref, la fonction choose permet au participant de cliquer sur une série de stimuli, d'afficher un symbole au-dessus des stimuli, et lorsqu'il clique à nouveau, le symbole disparaît.

Il est plus facile d'apprendre comment cela fonctionne à partir d'un exemple.

Dans l'exemple suivant, il y a trois symboles affichés à l'écran qui peuvent être sélectionnés avec un sélecteur bitmap. Les options de cette commande peuvent être définies avant que la commande choose ne soit appelée avec l'option choose. Le participant dispose de 60 secondes (60 000 millisecondes).

**Exemple de choix**
````
bitmaps
  markingsymbol
  house
  ball
  car
  exitsymbol1 ## shown when at least 2 selected
  exitsymbol2 ## shown when not enough are selected

task clickMysymbols
  show bitmap house # bitmap 1
  show bitmap ball  # bitmap 2
  show bitmap car   # bitmap 3
  choose option select markingsymbol
  choose option minselect 2
  choose option exit exitsymbol1 exitsymbol2 350 250
  choose 60000 1 3
  save RT CHOSEN_N CHOSEN_1 CHOSEN_2 CHOSEN_3
````
Notez les éléments suivants à propos de l'exemple ci-dessus :

* Il y a trois images sur l'écran.
* Si vous cliquez sur une image, l'image "markingsymbol" sera placée sur celle-ci.
* Si vous cliquez à nouveau, ce "markingsymbol" sera supprimé
* Le RT est le temps de réponse jusqu'à ce que le symbole de sortie ait été cliqué
* CHOSEN_N contient le nombre d'objets sélectionnés
* CHOSEN_1, CHOSEN_2, CHOSEN_3, etc. contient le numéro de l'objet. Ils seront toujours dans l'ordre numérique.

Il existe plusieurs autres options :

* choose option minselect : Le nombre minimum d'objets à sélectionner
* choose option maxselect : Les objets maxumum à sélectionner
* choose option sprites : choisir parmi les sprites au lieu des stimuli statiques
* choose option keep: Garde les images du sélecteur sélectionné par le participant à l'écran (par défaut, elles sont effacées immédiatement lorsque la fonction de choix est terminée)

La commande choose est particulièrement utile pour les tâches de mémoire.

### rate [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-rate){#task-rate}

Parfois, les gens veulent une échelle de Likert dans leur expérience. Par exemple, vous pouvez montrer un article de shopping et demander aux gens quelle est la probabilité que vous l'achetiez la semaine suivante sur une échelle de un à cinq. C'est maintenant super facile à faire.

**Exemple super simple d'utilisation de rate**
````
bitmaps
  something_for_sale

task wantit
  show bitmap something_for_sale -200 0
  rate 10000 5
  save RATE RATE_RT RATE_STATUS
````

Cela vous donne le type d'échelle de Likert le plus élémentaire. Par défaut, les points de l'échelle de Likert sont des cercles jaunes et à gauche et à droite, vous voyez une petite boîte blanche. En réalité, vous voulez beaucoup plus. Pour cela, vous pouvez utiliser des options. Tout d'abord, vous pouvez sélectionner un lieu avec l'option *pos* suivie de coordonnées x et y.

Dans l'exemple ci-dessous, l'échelle est maintenant indiquée à gauche du centre.

Exemple simple de rate
````
bitmaps
  something_for_sale

task wantit
  show bitmap something_for_sale -200 0
  rate option pos -200 0
  rate 10000 5
  save RATE RATE_RT RATE_STATUS
````

Dans l'exemple ci-dessous, nous ajoutons de plus belles images (bitmaps) au lieu des symboles par défaut. Dans PsyToolkit, il y a l'option "labels" pour *rate*, de sorte que vous pouvez faire une image avec les textes "pas du tout" et "beaucoup" ou juste de simples flèches  comme dans l'exemple ci-dessous. L'option *items* spécifie simplement l'image des points cliquables sur l'échelle.

De plus, dans l'exemple ci-dessous, nous avons 7 éléments et les personnes doivent faire un choix dans les 5 secondes.

**Exemple simple de rate**
````
bitmaps
  something_for_sale
  left_arrow
  right_arrow
  my_rectangle

task wantit
  show bitmap something_for_sale -200 0
  rate option pos -200 0
  rate option labels left_arrow right_arrow
  rate option items my_rectangle
  rate 5000 7
  save RATE RATE_RT RATE_STATUS
````

### save [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-save){#task-save}

Sauvegarde des variables. En général, une tâche se termine par une ligne de sauvegarde.

L'instruction de sauvegarde est d'une importance capitale, car elle garantit que les informations dont vous avez besoin pour votre analyse des données sont stockées. Par défaut, PsyToolkit ne conserve aucune information (contrairement à certains autres logiciels d'expérimentation). L'utilisateur doit indiquer au PsyToolkit quelles informations sont stockées dans le fichier de données.
En général, vous voudrez enregistrer l'état actuel, le bloc actuel (si vous avez plus d'un bloc), et au moins le temps de réponse (RT), et si le participant a répondu correctement ou non (STATUS). Les exemples présentés sur ce site web peuvent vous aider à comprendre cela.
Le meilleur endroit pour la commande de sauvegarde est à la fin de la description de votre tâche.

**Syntaxe**
````
save[liste de variables]
````

**Exemple pour save**
````
save BLOCKNAME RT STATUS
````

### sound [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-sound){#task-sound}

Utilisé pour jouer des sons. Un son commence juste à jouer, le code continue. Si vous ne voulez rien faire pendant le son, vous devez le faire suivre d'un délai. Vous pouvez également arrêter le son à tout moment en utilisant l'instruction *silence.*

**Syntaxe**
````

sound [sound name (as defined in 'sounds']
````

**Exemple pour sound**
````
sound MySoundFile
delay 200
silence MySoundFile
````

### if [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-if){#task-if}

Vous pouvez utiliser *if* pour exécuter seulement quelques commandes. Cela est souvent nécessaire pour afficher un feedback si les gens font une erreur. Le contraire de if est fi. fi sert à clore la liste de commandes conditionnelles

**exemple avec if**
````
task MyTask
  show bitmap stimulus
  readkey 1 1000
  if STATUS == CORRECT
    show bitmap WellDone
    delay 1000
    clear -1
  fi
  if STATUS != CORRECT
    show bitmap Mistake
    delay 2000
    clear -1
  fi
  if $x == &y
    show bitmap SmileyFace $x $y
  fi
````

### while [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-while){#task-while}

Comme pour if, vous pouvez mettre le code dans une *boucle while*. La boucle *while* se termine par la déclaration "while-end".

Tout ce qui se trouve entre *while* et  *while-end* sera exécuté jusqu'à ce que la condition de la ligne while soit satisfaite.

**Exemple de boucle while**
````
task MyTask
  set $mycounter 0
  while $mycounter < 10
    set $x random -200 200
    set $y random -200 200
    show bitmap SmileyFace $x $y
    set $mycounter increase
  while-end
````

Si vous faites une erreur, l'ordinateur peut être bloqué dans la boucle *while*. Par exemple, si vous n'augmentez pas la valeur de $mycounter dans l'exemple ci-dessus, le code sera bloqué et continuera à dessiner de nouveaux Smileys sur des localisations aléatoires.

## Instructions moyennement avancées [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_less_often_used_instructions){#less_often_used_instructions}

Certaines fonctions sont rarement utilisées ou nécessaires, mais elles ajoutent au potentiel des scripts du PsyToolkit.

### font [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#font){#font}

Vous pouvez définir la police de l'instruction *show text*.

**Exemple d'usage de font**
````
fonts
  MySmallFont arial.ttf 20
  MyBigFont arial.ttf 50

task Mytask
  font MySmallFont
  show text "small" 0 0
  font MyBigFont
  show text "small" 0 100
````
  
## Fonctions avancées{#s5-10}

### end [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#task-end){#task-end}

Vous pouvez terminer la tâche à n'importe quel moment de votre liste de d'actions dans une tâche. Vous pouvez même mettre fin à la liste de tâches en cours ou à l'ensemble de l'expérience. Il vous suffit de d'ajouter *end* à la tâche, à la liste de tâches ou à l'expérience. Cela peut être utile, par exemple, lorsque les gens sont en formation et que vous voulez arrêter le blocage des procès lorsqu'ils ont fait une erreur. Il s'agit toutefois d'une déclaration dont vous aurez rarement besoin.

### timestamp [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_timestamp){#timestamp}

L'horodatage (timestamp) peut être utilisé pour saisir l'heure actuelle. Cela peut être pratique si vous vérifiez l'heure passée dans une boucle while. Cela peut également être pratique si vous essayez de déboguer du code et de vérifier si le timing est conforme à ce qui est attendu.

Vous pouvez obtenir le timestamp-diff entre deux variables de timestamp en utilisant la commande set comme dans l'exemple ci-dessous. Les horodatages ne sont pas directement accessibles ou utilisables autrement que par la commande set timestamp-diff

**Exemples de timestamp**
````
task MyTask
  timestamp MyFirstTimestamp
  delay 1000
  timestamp MySecondTimestamp
  set $x timestamp-diff MyFirstTimestamp MySecondTimestamp
  save $x
````
### sprite [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_sprite){#sprite}

Dans PsyToolkit, les sprites sont un type de stimulus distinct (en plus de l'image bitmap, du rectangle, du cercle et du texte. Les sprites peuvent se déplacer et tourner. C'est idéal pour les expériences telles que le suivi d'objets multiples. Ils ont leurs propres commandes.

**Exemple basique montrant un sprite en mouvement**
````
bitmaps
  mystimulus

task MyTask
  sprite create mystimulus
  sprite 1 display
  sprite move direction 45 5
  delay 2000

block test
  tasklust
    MyTask 1
  end
  
````

La vitesse des sprites en mouvement est basée sur différents facteurs. La vitesse dépend de la fréquence de mise à jour de l'écran. Cela signifie simplement que si vous utilisez des expériences sur différents systèmes, vous pourriez avoir des vitesses des sprites en mouvement légèrement différentes. Consultez les exemples du package Linux pour voir comment les commandes ci-dessous fonctionnent.


| Nom de la fonction                                                      | Ce que cela fait                             | Exemple                                      |
|-------------------------------------------------------------------------|----------------------------------------------|----------------------------------------------|
| **Créer un sprite* *                                                    |                                              |                                              |
| `sprite create [bitmap]`                                                | Crée un stimulus au centre l'écran           | sprite create MyStimulus                     |
| `sprite create [bitmap] [x][y] `                                        | Crée un stimulus et le positionne            | sprite create MyStimulus 100 50              |
| `sprite create [bitmap] [x][y][angle][speed]`                           | Crée un stimulus, le positionne et le bouge  | sprite create MyStimulus 100 50 45 5         |
| **Afficher les sprites**                                                |                                              |                                              |
| `sprite [sprite] display`                                               | Rend le sprite 1 visible                     | sprite 1 display                             |
| `sprite [sprite] hide`                                                  | Cache le sprite 1                            | sprite 1 hide                                |
| `sprite [sprite] freeze `                                               | Stoppe le mouvement                          | sprite 1 freeze                              |
| `sprite [sprite] move`                                                  | remet en mouvement                           | sprite 1 move                                |
| **déplacer les sprites**                                                |                                              |                                              |
| `sprite [sprite] jump (xpos)(ypos)`                                     | Change de position une fois                  | sprite 1 jump 200 100                        |
| `sprite [sprite] move (to/towards) (xpos)(ypos)(speed) `                | Définit une direction                        | sprite 1 move to 200 100 5                   |
| `sprite [sprite] move direction (angle)(speed)`                         | Bouge dans une direction                     | sprite 1 move direction -90 4                |
| `sprite [sprite] move path (speed) x1 y1 … xn yn`                       | Bouge le long d'un ensemble de localisations | sprite 1 move path 3 200 100 -200 100 300 50 |
| `sprite [sprite] evade`                                                 | Les sprites ne se croiseront pas             | sprite 1 evade                               |
| `sprite [sprite] borders [left][right][top][bottom]`                    | Le sprite se heurtera à ces frontières fixes | sprite 1 borders -300 300 -200 200           |
| **rotation/défilement des sprites**                                     |                                              |                                              |
| `sprite [sprite] rotate [speed in degrees per refresh rate]`            | Faire tourner un sprite en continu           | sprite 1 rotate -7                           |
| `sprite [sprite] rotate to [angle] [speed in degrees per refresh rate]` | Faire tourner un sprite progressivement      | sprite 1 rotate to 270                       |
| `sprite [sprite] rotate now [angle] `                                   | Faire tourner un sprite                      | sprite 1 rotate now 45                       |
| `sprite [sprite] hscroll [speed]`                                       | Faites défiler un sprite                     | sprite 1 hscroll -3                          |
| **Changer les sprites**                                                 |                                              |                                              |
| `sprite [sprite] speed (speed)`                                         | vitesse fixée                                | sprite 1 speed 2                             |
| `sprite [sprite] accelerate (speed change)`                             | ajuste la vitesse                            | sprite 1 accelerate 3                        |
| `sprite [sprite] bitmap [bitmapname]`                                   | changer l'apparence                          | sprite 1 bitmap smiley                       |
| **commandes sur tous les sprites à la fois**                            |                                              |                                              |
| `sprites [options] all`                                                 | agir sur tous les sprites en une seule ligne | sprites display all                          |

## Instructions pour les équipements spéciaux [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#_instructions_for_special_equipment){#instructions_for_special_equipment}

Les équipements spéciaux sont principalement les cartes d'entrée/sortie et les claviers spéciaux. Je recommande les claviers Cedrus. Si vous le souhaitez, vous pouvez construire votre propre clavier. Cela permet d'économiser beaucoup d'argent. Vous pouvez le brancher sur le port parallèle (si vous en avez un). Ce clavier est appelé "ultra" (conçu par Felix Frey, Université de Leipzig), et un document expliquant comment le construire est disponible gratuitement.

### cedrus readkey{#cedrusreadkey}
Attendre une touche spécifique de votre clavier USB Cedrus. Assurez-vous que vous savez quelle touche a quelle valeur numérique (vous pourriez vouloir faire quelques expériences à ce sujet, et il existe un exemple de programmation qui vous montre le numéro de chaque touche). Sous Linux, vous pouvez appeler cela en utilisant la commande "testcedrus", qui est fournie avec PsyToolkit.

## Tables [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#table){#table}
Les tableaux ont des lignes et des rangées. Chaque fois qu'un tableau est utilisé dans une tâche, une de ses lignes est choisie. Chaque colonne peut être référencée en utilisant le signe @. Par exemple, @2 fait référence à la deuxième colonne de la ligne qui est choisie pour un essai de tâche donné. Dans le bloc, l'utilisateur peut spécifier comment les lignes du tableau sont sélectionnées. La sélection par défaut est aléatoire, mais il existe d'autres moyens (par exemple : ordre fixe, répétition à l'essai).

**Exemple de table**
````
table MyTable
 10  2  bitmap1
-10  1  bitmap2
````

**Exemple de table avec des chaines de caractères**
````
table MyTable
 10  2  bitmap1  "condition one"
-10  1  bitmap2  "condition two"
````
Dans une tâche qui utilise un tableau (avec l'instruction [table](#task-table)), chaque colonne peut être référencée avec le signe @. Ainsi, \@2 renvoie à la deuxième colonne de la ligne du tableau qui a été sélectionnée.

Chaque fois qu'une tâche est exécutée, une seule ligne du tableau associé est sélectionnée. Par défaut, une ligne est choisie au hasard. Il existe d'autres façons de choisir des lignes de tableau (en utilisant l'instruction [tasklist](#block-tasklist) dans les [blocs](#block)).

Dans chaque essai de tâche avec un tableau, vous avez non seulement accès aux colonnes, mais vous pouvez également obtenir le numéro de la ligne de la table. La variable est appelée TABLEROW. Cela peut être pratique pour sauvegarder des données. S'il y a beaucoup de données importantes dans chaque tableau que vous voulez les utiliser dans votre analyse, vous pouvez ainsi vous assurer quel ligne a été utilisée.

## block [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block){#block}

Dans les expériences, les essais se font par blocs. Un bloc d'essais signifie que le participant effectue, par exemple, 100 essais de la tâche Stroop. Vous pouvez aussi faire une pause au milieu, et créer deux blocs de 50 essais à la place. Les blocs appellent des tâches, donc vous devez vraiment avoir au moins un bloc dans votre script PsyToolkit. Les blocs peuvent être complexes, mais ils peuvent aussi être très simples, comme cet exemple ci-dessous.

**Exemple de bloc simple, appelant la tâche stroop 100 fois**
````
block MyBlock
  tasklist
    strooptask 100
  end
````

#### bitmap [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-bitmap){#block-bitmap}

L'instruction [bitmap](#bitmap) est simple. Vous voulez souvent afficher une image avec une instruction et attendre qu'on appuie sur une touche.

**Example de bitmap dans un bloc**
````
block Myblock
  bitmap MyInstruction
  wait_for_key
  tasklist
    strooptask 100
  end
````
L'affichage d'une bitmap dans une tâche et dans un bloc est différent. Ici, dans les blocs, il ne faut pas mettre le mot "show" avant le bitmap. Dans les tâches, vous devez le faire. Il y a de bonnes raisons à cette distinction (dans les tâches, les stimuli sont rapides, alors que dans les blocs, ils sont considérés comme des instructions).

#### sound [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-sound){#block-sound}

Comme dans la tâche, vous pouvez démarrer un son avec *[sound](#sound)* et l'arrêter avec *silence*

Exemple avec sound dans un bloc
````
block Myblock
  sound welcometune
  bitmap MyInstruction
  wait_for_key
  silence welcometune
  tasklist
    strooptask 100
  end
````

#### delay [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-delay){#block-delay}

Comme pour les tâches, vous pouvez introduire une pause [delay](#delay). Parfois, c'est bien pour les comptes à rebours.

**Exemple avec delay dans un bloc**
````
block Myblock
  bitmap number3
  delay 500
  bitmap number2
  delay 500
  bitmap number1
  delay 500
  tasklist
    mytask 100
  end
````

#### message [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-message){#block-message}

Au lieu d'afficher un image (bitmap) et d'attendre un appui-touche, vous pouvez combiner tout cela en une seule commande, appelée *message*.

**Exemple de message dans un bloc (en attente de la barre d'espacement, qui est la touche par défaut)**
````
block Myblock
  message MyInstruction
  tasklist
    strooptask 100
  end
  message ThankYouBitmap
````

**Exemple de message en bloc (exemple en attente de la touche "b")**

````
block Myblock
  message MyInstruction b
  tasklist
    strooptask 100
  end
  message ThankYouBitmap
````

Vous pouvez utiliser la touche de la souris au lieu du clavier. Veillez à ce que cela soit clairement indiqué dans le message. Le participant poursuivra ensuite en cliquant (ou en touchant) n'importe où sur l'image bitmap de l'instruction.


**Exemple de message en bloc (exemple d'attente d'une pression sur le bouton de la souris au lieu du clavier)**
````
block Myblock
  message MyInstruction mouse
  tasklist
    strooptask 100
  end
  message ThankYouBitmap
````

#### pager [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-pager){#block-pager}

Parfois, vous voulez une série d'instructions et vous laissez l'utilisateur les parcourir. En d'autres termes, vous avez une série d'images (ou "pages", d'où le mot "pager") que vous voulez montrer les unes après les autres. La commande pager vous permet de faire exactement cela.

* L'utilisateur peut utiliser les touches fléchées et utiliser la touche Q pour s'en sortir. La barre d'espacement permet de passer à l'image/page suivante. Assurez-vous que toutes ces images se trouvent dans la section bitmap.
* Vous pouvez également utiliser la souris au lieu du clavier (ci-dessous).Veillez à indiquer dans les instructions la façon dont les utilisateurs naviguent dans l'image et comment ils en sortent.

**Exemple de pager dans un bloc**
````
block Myblock
  pager MyInstruction1 MyInstruction2 MyInstruction3 MyInstruction4
  tasklist
    strooptask 100
  end
````
Vous pouvez également utiliser la souris (ou le toucher) pour faire défiler les pages d'instructions. Pour cela, vous devez donner quelques informations supplémentaires. Si vous êtes débutant, essayez d'abord les pagers de base comme expliqué ci-dessus.

Le pager souris/tactile est parfois plus utile (par exemple, les expériences sur l'écran tactile). Dans l'exemple ci-dessous, nous utilisons l'option "pager" pour dire à l'ordinateur ce qui suit :

*utilisez la souris avec pager
*L'image nommée "back" devra être présentée à la position -200 200
*L'image nommée "next" devra être présentée à la position 0,200
*L'image nommée "start" devra être présentée à la position 200 200

Ainsi, outre les instructions, chaque écran comporte 3 images, une pour revenir en arrière, une pour avancer et une pour quitter les instructions. Cette dernière n'est affichée qu'une fois que le participant les a toutes parcourues. Notez que pour cette expérience, vous devez disposer de bitmaps pour les images : back, next, start, MonInstruction1, MonInstruction2, MonInstruction3.

**Exemple avec pager utilisant la souris dans un bloc**
````
block Myblock
  pager option mouse back -200 200 next 0 200 start 200 200
  pager MyInstruction1 MyInstruction2 MyInstruction3
  tasklist
    strooptask 100
  end
````
#### Paramétrer les variables [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-set){#block-set}

Parfois, vous souhaitez définir une variable globale. Vous pouvez le faire tout comme vous le feriez dans les tâches. Par exemple, vous pouvez fixer le temps de réponse maximum à une valeur plus élevée pendant la formation.

**Exemple de paramétrage d'une variable dans un bloc**
````
block MyTraining
  pager MyInstruction1 MyInstruction2 MyInstruction3 MyInstruction4
  set &MaxResponseTime 2000
  tasklist
    strooptask 20
  end

block MyRealDatablock
  set &MaxResponseTime 1000
  pager MyInstruction1 MyInstruction2 MyInstruction3 MyInstruction4
  tasklist
    strooptask 100
  end
````

#### tasklist [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-tasklist){#block-tasklist}

Chaque bloc comporte une liste de tâches. Celle-ci décrit les tâches qui sont appelées, combien de fois et dans quel ordre. Vous pouvez avoir une ou plusieurs tâches. Il est rare d'avoir plusieurs tâches, mais cela peut être le cas dans les paradigmes de commutation de tâches. Sur chaque ligne de la liste des tâches, vous devez au moins indiquer le nom de la tâche et le nombre d'essais.

**Exemple simple de tasklist**
````
block MyTraining
  tasklist
    strooptask 20
  end
````

Vous pouvez spécifier que vous voulez que chaque fois que les gens font une erreur, le même processus doit être répété, en utilisant *repeat_on_error*. Si vous utilisez cette méthode, vous devez préciser ce qui est considéré comme une erreur en utilisant la déclaration d'erreur (voir l'exemple ci-dessous).

*Repeat_on_error* ne fonctionne que lorsque vous utilisez des tableaux, les variables aléatoires ne sont pas fixées aux mêmes valeurs.

**Exemple simple de tasklist**
````
table MyTable
  "condition1" 255 0 0 1 ## respond with "r" to red rectangle
  "condition2" 0 255 0 2 ## respond with "g" to green rectangle

task Mytask
  table MyTable
  keys r g
  show rectangle 0 0 50 50   @2 @3 @4
  readkey @5 2000
  if STATUS == WRONG
    error ## this makes this trial an error for the repeat_on_error process
  fi
  save @1 STATUS RT

block MyTraining
  tasklist
    Mytask 10 repeat_on_error
  end
````
Dans l'exemple ci-dessus, vous voyez un rectangle rouge ou vert (présenté à la position 0,0, qui est le centre de l'écran, et 50px de large et 50px de haut). Vous devez répondre avec la touche "r" ou "g". Vous vous demandez peut-être pourquoi vous devez spécifier explicitement ce qu'est une erreur si vous utilisez *repeat_on_error*. C'est une bonne question, car dans l'exemple ci-dessus, c'est effectivement une erreur si la personne répond avec la mauvaise touche. Mais il y a des expériences dans lesquelles vous voulez en fait que les gens ne répondent pas (c'est-à-dire que la valeur de STATUT est TIMEOUT). Et dans certaines expériences, il y a plus d'une réponse par essai. *repeat_on_error* vous donne un contrôle total sur ce qu'est une erreur et ce qu'elle n'est pas.
Dans certaines expériences, vous pouvez souhaiter que tous les participants effectuent les essais exactement dans le même ordre. Vous pouvez simplement parcourir chaque ligne de votre tableau des tâches. Pour cela, vous utilisez l'option *fixed*.

**Exemple simple de tasklist**
````
block MyTraining
  tasklist
    strooptask 20 fixed
  end
````

Dans certaines expériences, vous pouvez souhaiter que les participants fassent au moins un certain nombre d'essais corrects. Pour cela, vous utilisez l'option *correct*. Dans l'exemple ci-dessous, le participant doit avoir fait 10 essais corrects, mais après 100 essais, il s'arrêtera, quel que soit le nombre d'essais corrects. Dans la variante *allcorrect*, les essais doivent être consécutivement corrects.

**Exemple simple de tasklist**
````
block MyTraining
  tasklist
    strooptask 10 correct 100
  end

block MyTraining
  tasklist
    strooptask 10 allcorrect 100
  end
````

Enfin, vous voulez parfois que les essais ne se répètent jamais. Il y a trois façons d'obtenir cela dans l'instruction *tasklist*

* all_before_repeat : faire tous les essais comme dans le tableau, choisis au hasard, mais les faire tous avant de les choisir à nouveau
* no_repeat : ne jamais répéter immédiatement un essai du tableau (c'est-à-dire que la même ligne d'un tableau ne sera pas répétée lors du prochain essai)
* fixed : faire les essais dans l'ordre où ils se trouvent dans le tableau

Dans l'exemple suivant, il n'y a que trois entrées sur la liste proposée. Elles ne seront pas répétées tant qu'elles ne seront pas toutes terminées. Vous pouvez ajouter explicitement que vous ne voulez jamais les répéter.

**Exemple de tasklist**
````
table MyTable
  bitmapBlue
  bitmapRed
  bitmapGreen

task strooptask
  table MyTable
  keys space
  show bitmap @1
  readkey 1

block MyTraining
  tasklist
    strooptask 10 all_before_repeat no_repeat
  end
````

Si vous avez fixé des blocs consécutifs, mais que vous utilisez la même tâche et le même tableau, vous continuerez à partir de la ligne du tableau d'où vous étiez parti. C'est une fonction pratique au cas où vous voudriez passer par de nombreuses essais, mais où les gens ont parfois besoin d'une pause. Assurez-vous que vous avez toujours une instruction end à la fin de votre liste de tâches

#### maxtime [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-maxtime){#block-maxtime}

Vous pouvez fixer la durée maximale d'un bloc (en millisecondes, secondes ou minutes). C'est très simple. Voici un exemple d'un bloc qui peut durer au maximum 2 minutes. Vous pouvez avoir des instructions avant la liste des tâches (par exemple, [message](#message) ou [pager](#pager), elles ne sont pas prises en compte dans le temps maximum).

**Exemple de bloc avec maxtime de 2 minutes (notez le m)**
````
block MyTraining
  maxtime 2m
  tasklist
    strooptask 10 all_before_repeat no_repeat
  end
````
**Exemple de bloc avec maxtime de 100 s (notez le s)**
````
block MyTraining
  maxtime 100s
  tasklist
    strooptask 10 all_before_repeat no_repeat
  end
````
**Exemple de bloc avec maxtime, avec des variables que vous devez spécifier en millisecondes**
````
block MyTraining
  maxtime &MyVariable
  tasklist
    strooptask 10 all_before_repeat no_repeat
  end
````

#### feedback [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#block-feedback){#block-feedback}

Feedback can be used to create feedback to the participant, for example about the average response speed. Creating feedback is part of the "block" structure. Feedback is described in a separate document, because it is of advanced use: [how to use feedback](https://www.psytoolkit.org/doc3.1.0/feedback.html)

### blockorder [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#blockorder){#blockorder}

Par défaut, les blocs sont effectués dans l'ordre où ils sont décrits dans votre code. Vous pouvez modifier cet ordre en réorganisant le code du bloc, mais il existe un moyen plus simple et plus rapide : l'instruction *blockorder*. En utilisant *blockorder*, vous pouvez lister les blocs que vous voulez faire et l'ordre dans lequel vous voulez les faire.

L'idée derrière cette fonction est simplement la rapidité du codage, et la facilité pour changer l'ordre (par exemple pour le contreblancement). Dans l'exemple suivant, imaginez qu'il existe un code pour trois blocs, appelés formation, test1 et test2. L'exemple suivant montre comment définir l'ordre de ces blocs de différentes manières.

**Exemple d'utilisation de blockorder**
````
blockorder
  training
  test1
  test2
````

Plus important encore, vous pouvez avoir plus d'un blockorder. Lorsque vous avez plus d'un blockorder, PsyToolkit en choisira un au hasard. Le blockorder choisi sera stocké dans la variable BLOCKORDER. Par défaut, cette variable contient la valeur 1, mais si vous avez donné, par exemple, 3 blockorder, cette valeur peut être comprise entre les valeurs 1 et 3. Vous trouverez ci-dessous un exemple de cette utilisation.

Dans l'exemple ci-dessous, l'ordinateur choisira l'un des deux blockorder au hasard. C'est ce que l'ordinateur fera lorsqu'il verra deux blockorder. C'est très utile pour faire un contrebalancement, par exemple si vous voulez que certains participants commencent avec une tâche et d'autres avec l'autre.

**Exemple d'utilisation du blockorder (notez que ces tâches ne font rien de significatif)**
````
task color_task
  keys a l
  readkey 1 1000
  readkey
  save BLOCKORDER BLOCKNAME TASKNAME RT

task shape_task
  keys a l
  readkey 1 1000
  readkey
  save BLOCKORDER BLOCKNAME TASKNAME RT

blockorder
  training
  color_task
  shape_task

blockorder
  training
  shape_task
  color_task
````

### include (usage avancé seulement) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#include){#include}

Vous pouvez inclure un autre fichier dans votre script. Cela peut être utile si vous travaillez avec de très grands tableaux que vous voulez stocker dans un fichier séparé. Toute ligne commençant par "include" suivie d'un nom de fichier utilisera ce nom de fichier à cet endroit du script. Les fichiers inclus doivent se trouver dans le même répertoire que le fichier principal du script utilisant *include*.

### part (pour utilisateur avancé) [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#part){#part}

Vous pouvez écrire des "bribes" de quelques lignes et les inclure ailleurs dans votre script. C'est pratique si vous avez plusieurs tâches ou blocs qui sont globalement les mêmes à l'exception de quelques lignes. Vous pouvez ainsi utiliser *part* au lieu de retaper tout le script. *part* remplace simplement le texte dans votre code. L'objectif principal est d'avoir un code plus court et plus efficace sans avoir à répéter les mêmes choses.

**Exemple d'utilisation de part**
````
part showAnimatedSquare
  show rectangle 0 0 50 50  255 255 0
  delay 100
  show rectangle 0 0 100 100  255 255 0
  delay 100
  show rectangle 0 0 150 150  255 255 0
  delay 100

part removeSquare
  clear -1 -2 -3

task some_task
  keys space
  part showAnimatedSquare
  readkey 1 1000
  part removeSquare
  delay 100

task another_task
  keys a
  part showAnimatedSquare
  readkey 1 5000
  part removeSquare
  delay 200

block test
  tasklist
    some_task 10
  end

block test
  tasklist
    another_task 10
  end
````
## Vue d'ensemble de toutes les variables du système [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#sysvars){#sysvars}

Vous trouverez ci-dessous un aperçu rapide de presque toutes les variables "système" que vous pouvez utiliser dans votre script d'expérience. Elles sont décrites en détail dans le texte, mais ici elles sont toutes ensemble. Elles contiennent généralement toutes une valeur numérique, sauf pour TASKNAME et BLOCKNAME. Ces deux derniers ne sont utiles que dans l'instruction de sauvegarde. Les variables liées au choix ne sont pas énumérées. Elles doivent toutes être écrites en majuscules.

* RT : dernier temps de réponse provenant de readkey ou readmouse
* STATUS : de readkey(s)/readmouse, il peut être CORRECT, WRONG, TIMEOUT (or 1, 2, 3)
* KEY : la touche qui a été préssée dansle dernier readkey/keystatus (un nombre)
* MOUSE_X : la position x de la souris dans le dernier état de readmouse
* MOUSE_Y : la position x de la souris dans le dernier état de readmouse
* TABLEROW : ligne du talbeau, choisie au hasard une fois par essai
* TASKNAME : le noom de la tâche à laquelle appartient l'essai
* TRIALCOUNT : le nombre de d'essais réalisés jusqu'à présent dans le cadre de n'importe quelle tâche
* BLOCKNUMBER : Le numéro du bloc courant. Il démarre à 1. 
* BLOCKNAME : le nom du bloc courant auquel appartient l'essai
* BLOCKORDER : Est normalement de 1, mais si plusieurs blockorder sont définis, donne le numéro d'e l'ordre de blocage'un blockorder choisi au hasard
* RATE : La valeur choisie de l'échelle de d'évaluation
* RATE_RT : Le RT du processus d'évaluation
* RATE_STATUS : sera de 1 s'il est noté, ou de 3 s'il y a un délai d'attente (il n'y a pas de réponse correcte, bien sûr)

## Liens vers toutes les instructions [![](img/ukflag.png)](https://www.psytoolkit.org/doc3.2.0/syntax.html#overview){#syntax_overview}

(cette liste n'est pas encore complète)

* [Options basiques](#options) : [origin](#options-origin) | [bitmapdir](#options-origin) | [sounddir](#options-origin) | [fontdir](#options-origin) | [fullscreen](#options-fullscreen) | [resolution](#options-resolution) | [version](#options-version) | [mouse](#options-mouse)| [variable](#options-variable) | [window](#options-window) | [screensize](#options-screensize) | [screendistance](#options-screendistance) | [vsync](#options-vsync) | [egi](#options-egi)| [escape](#options-escape)| [parallelport](#options-parallelport)|  [pcidio24](#options-pcidio24)| [cedrus](#options-cedrus) | [iolab](#options-iolab)| [eye-tracker](#option-et)| [executable](#options-executable)

* [Instructions de base](#_commonly_used_instructions) : [key](#task-key)| [show](#task-show) | [bitmap](#task-bitmap) | [text](#task-text)| [clear](#task-clear)| [sound](#task-sound)| [keys](#task-key)| [readkey](#task-readkey) | [delay](#task-delay) | [save](#task-save) | [table](#task-table)

* [Instructions moyennement avancées](#less_often_used_instructions) : [readmouse](#task-readmouse) | [if](#task-if) | [while](#task-while) | [move](#task-move) | [relocate](#task-relocate) | [hide](#task-hide) | [unhide](task-unhide) | [font](#task-font)

* [Instructions avancées](#very_advanced_instructions) : [readkeys](#task-readkeys) | [readmouse](#task-readmouse)| [keystatus](#task-keystatus) | [choose](#task-choose) | [set](#task-set) | [progress](task-progress) | [timestamp](#timestamp) | [sprite](#sprite) | [end](#end)

* [Instruction de bloc](#block) : [bitmap](#block-bitmap2) | [sound](#block-sound2) | [delay](#block-delay2) | [message](#block-message) | [pager](#block-pager) | [set](#block-set) | [tasklist](#block-tasklist) | [feedback](#block-feedback) | [block-maxtime](#block-maxtime)

* [Instructions spéciales](#s5-13) : [include](#include) | [part](#part) | [blockorder](#blockorder)

* [vue d'ensemble des variables systèmes](#sysvars)

